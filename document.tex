% DOCUMENT BODY
\maketitle

%\tableofcontents

\begin{abstract}

  We consider bootstrapping computers, also known as bare metal provisioning, in a more general context of deployments and dependent builds. We review the state of the art, exhibit a functional programming inspired data model that expresses builds declaratively and specialize it to a boot context, and discuss the need for and components of a trust-oriented security model for provisioning.

\end{abstract}

\section{Introduction}

Booting computers has long been a somewhat neglected corner of IT infrastructure. 
%
It is often easy to ignore the sequence of unfamiliar and usually poorly documented ephemeral stages a computer quickly steps through between a power cycle and normal operation. 
%
Indeed, one usually expects that a correctly configured system spends only a tiny fraction of its life cycling through these stages.

Despite this, there are a few reasons one may wish to expend attention on the bootloader. 
%
Paramount among these is \emph{security.} 
%
In order to evaluate the security of the software supply chain deployed in a computer system, one must trace the root of trust all the way to the beginning of a power cycle.
%
This entails careful formulation and analysis of the security invariants that ought to be preserved during the execution and handoff of each stage of the boot sequence. %, and measurement of system state during instantiations to detect failures of these properties.

A second, related issue is \emph{determinism}, that is, the idea that the same boot process configuration will yield the same system state transition regardless of context.
%
To this end, both compilation and building of the deployed software and execution of initialization code must be reproducible from a clear task description that makes all inputs explicit.
%
Reproducibility of execution can be detected in practice by making careful \emph{measurements} of system state at critical stages.

\begin{comment}
\begin{remark}
  
  Clearly, it is neither practical nor desirable for system state to be literally immutable, or reproducible: at the very least, we expect that the machine clock ticks on, IP traffic is processed, logs accumulate, and the state of stateful software evolves whle the machine is operational.

  Nonetheless, some 
  %
  A simple view on determinism asks only that the configuration and software installed on a system together with the set of active services be reproducible.
  %
  In a Linux environment, this might mean invariance of the contents of the $\mathtt{/boot}$, $\mathtt{/etc}$, and $\mathtt{/usr}$ trees.

\end{remark}
\end{comment}

We think the bootloader is overdue a modern theoretical treatment. 
%
In this article we address the question:
\begin{quote}
  What type of thing is a boot sequence?
\end{quote}
%
An answer to this question empowers us to draw analogies with other types of computation and make more precise and interpretable security claims.
%
A well-defined data model for defining boot sequences can have a number of benefits:

\begin{itemize}
\tightlist
\item
  \emph{Accessibility.} A modern, implementation-agnostic description language means more users understanding and taking control of their own boot sequences.
\item
  \emph{Security.} A serialized boot definition can be used as a part of a \emph{software bill of materials} which is the subject of security claims about a deployment.
\item
  \emph{Extensibility.} The present obscure state of documentation makes it difficult for developers to integrate new technologies such as novel storage backends early in the boot process.
\end{itemize}

The second question we address in this article is:
\begin{quote}
  How can boots be trusted?
\end{quote}

The answers to these questions cannot be divorced from one another.
%
In order to make trustworthy claims about boots, we have to be able to clearly state the subject of the claims.
%
On the other hand, a formal definition of a boot cannot have much practical significance if users cannot be sure that the state reached by their system matches the definition.

In \S\ref{build} we introduce a data model for defining computations and exhibit how typical boot sequence paradigms can be expressed in this model.
%
In \S\ref{security} we discuss elements that would be needed for a formal cybersecurity framework and review some ubiquitous examples with this in mind.


\subsection{Related work}\label{related-work}

For a thorough engineering overview of the structure of boot processes at the firmware level, see \cite{yao2020building}.

There are many cross-industry initiatives to develop standards associated to the boot process:
\begin{itemize}
  \item
   The \emph{Universal Extensible Firmware Interface} (UEFI) is a set of cross-platform standards for an execution environment presented by platform firmware which early stage boot manager or bootloader software can hook into.\footnote{\url{https://uefi.org/specifications}}

  \item
    The \emph{Preboot Execution Environment} (PXE, pronounced `pixie') is a component of the UEFI specification that defines a protocol, based on DHCP and TFTP, for negotiating a network boot.
    %
    It is the standard way to load the next stage after platform firmware over a network, although some systems also offer boot from a webserver.

  \item
    The \emph{Extended Bootloader Base Requirements} (EBBR) are a subset of UEFI designed as a specification compatible with U-Boot, the industry standard firmware and bootloader implementation for embedded systems.\footnote{\url{https://arm-software.github.io/ebbr/}}

  \item
    The \emph{multiboot} specification and its sequel does some work to define the format of OS kernel loaders. 
    %
    Unlike the preceding examples, multiboot does not attempt to specify how systems should operate at the platform firmware level --- its scope is limited to starting an OS.
    %
    The reference implementation of a multiboot-compliant host is the GRUB boot manager, widely used in booting Linux or BSD on x86 computers (although Linux and BSD are not usually distributed as a multiboot-compliant client!)

  \item
    The \emph{boot loader specification} project defines disk formats, file formats, and naming conventions for boot loader menu entries.\footnote{\url{https://uapi-group.org/specifications/specs/boot_loader_specification/}} 
    %
    BLS-compliant menu entry configurations are intended to be OS-agnostic and can be thought of as a data model for a kernel loader boot stage.
    %
    However, boots defined in this format are limited to ones where the boot artifacts are located on local storage, which must be partitioned in one of a few pre-defined layouts. 
    %
    Thus \emph{extensibility} cannot be said to be one of the goals of the project.

\end{itemize}

Applications designed for bare-metal provisioning of fleets of devices in data centres must define their own data model for specifying deployments.
%
Generally speaking, these systems operate over a network (hence use network-based boot protocols, the major one being PXE) and are opinionated about the structure of boot flow.
%
Some examples are OpenStack's \emph{Ironic},\footnote{\url{https://wiki.openstack.org/wiki/Ironic}}, Canonical's \emph{MaaS},\footnote{\url{https://maas.io}}, and Equinix's \emph{Tinkerbell}.\footnote{\url{https://tinkerbell.org/}}

The OpenStack authors have written on the need for a standardized bare metal provisioning API \cite{openstack2023building}.

The early boot and system initialization standards are accompanied by standards defining data models and serialization formats for hardware devices.
%
These models aggregate the addressing systems of various bus types (e.g. PCI) into a single namespace.
%
As well as providing essential input data for boot loaders to discover and initialize peripherals, a path-like serialization format is useful for specifying the location of boot images and configuration in boot definitions.
%
\begin{itemize}
  \item
    The UEFI specification includes a systematic and quite general language of \emph{devpaths} for defining \emph{locations} for sourcing images.\footnote{\url{https://uefi.org/specs/UEFI/2.10/10\_Protocols\_Device\_Path\_Protocol.html}}

    A related standard is the \emph{Advanced Configuration and Power Interface} (ACPI) device model. 
    %
    ACPI is also maintained by the UEFI Forum and can be invoked within UEFI devpaths, but is more commonly used for initialising a booted operating system.
    
  \item
    The Devicetree specification provides an alternative data model and accompanying source and binary formats for informing bootloaders about hardware layout.\footnote{\url{https://www.devicetree.org/}}
\end{itemize}

Regarding reproducibility, the subject of \emph{reproducible builds} in software distribution has already received a fair amount of attention \cite{lamb:hal-03196519}.\footnote{\url{https://reproducible-builds.org}}
%
As for reproducibility of system state, the approach of \emph{measurements} in boot sequences is well established and widely implemented in standard hardware \cite{kinney2006trusted}.\footnote{\url{https://trustedcomputinggroup.org/}}
  
\begin{comment}
TODO
  The latter is clearly related in spirit to the idea of \emph{immutable infrastructure}.
  %
  This term is commonly used to refer to the phoenix server model,\footnote{} where servers are redeployed from scratch --- in particular, including a power cycle --- whenever an upgrade is requested.
  %
  If deployments from scratch are reproducible, then this system ensures that upgrades are reproducible too.

  But for a deployment to be reproducible, every stage of the deployment should also be reproducible; with a suitable system for caching intermediate states that remain invariant on an upgrade, reproducibility can be achieved without a phoenix server model.
\end{comment}

\section{Boots as builds} \label{build}

A boot can be regarded as a set of steps to compute the state of an initialized system. 
%
In some cases, recomputing the value with updated inputs (i.e.~rebooting) can be accelerated using a caching strategy, so that a reboot may occur without necessarily going through a full power cycle.
%
In some cases, the requirements to launch a boot stage can be provided by more than one environment, so that the same target can be reached in multiple ways.

In \S\ref{data-model}, we define a data model rich enough to specify describing builds with multiple valid routes to the target.
%
Subsequently, we show several ways to express some common boot pathways in this model.

\subsection{Data model} \label{data-model}

\begin{definition}
  
  An \emph{n-ary operation} from types \((T_1,\ldots,T_n)\) to type \(T_0\) is defined to be a function \(f:\prod_{i=1}^n T_i \rightarrow T_0\).\footnote{For the purposes of this paper, a `type' can be understood as a set.}
  %
  Note that the (single) output and inputs of an \(n\)-ary operation are indexed together, in that order, by \([n]:=\{0,\ldots,n\}\).

  A \emph{task} is an operation \(f\) of any arity \(n\) together with a labelling \(\mathtt{name}:[n]\rightarrow \mathtt{String}\) of the inputs and output by strings and a ``task description,'' which should be an explicit expression of some $n$-ary operation comprehensible in the context in which the task will be used.
  %
  The label \(\mathtt{name}(0)\) of the output of the operation is called the \emph{target} of the task.

  A \emph{build specification} or simply \emph{build} is a set of tasks.

\end{definition}

Expressed in a Python-like pseudocode, the data schema looks something like the following:

\begin{lstlisting}
[
  (name_0, f, [name_1, ..., name_n]),
  ...
]
\end{lstlisting}

In this picture, the task description would be a Python function and the labelled source and destination types are denoted by (typed) named variables.

We express the same data more verbosely in a JSON format:

\begin{comment}
\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{[}
    \FunctionTok{\{}
        \DataTypeTok{"target"}\FunctionTok{:} \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_0"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_0"}\FunctionTok{\},}
        \DataTypeTok{"inputs"}\FunctionTok{:} \OtherTok{[}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_1"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_1"}\FunctionTok{\}}\OtherTok{,}
            \ErrorTok{...}\OtherTok{,}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_n"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_n"}\FunctionTok{\}}\OtherTok{,}
        \OtherTok{]}\FunctionTok{,}
        \DataTypeTok{"task"}\FunctionTok{:} \ErrorTok{@td}
    \FunctionTok{\}}\OtherTok{,}
    \ErrorTok{...}
\OtherTok{]}
\end{Highlighting}
\end{Shaded}
\end{comment}

\begin{lstlisting}
[
  {
    "target": {"label": "name_0", "type": "T_0"},
    "inputs": [
      {"label": "name_1", "type": "T_1"},
      ...,
      {"label": "name_n", "type": "T_n"},
    ],
    "task": @td
  },
  ...
]
\end{lstlisting}

Here \texttt{@td} should be some task description schema whose details we leave unspecified.

\begin{definition}
  Let \(B\) be a build and \(t\) a target of \(B\), and \((i_1,\ldots,i_k)\) a set of labels. 
  %
  A \emph{solution} of \((B,t,(i_1,\ldots,i_k))\) is a subset \(S\) of \(B\) such that:

  \begin{itemize}
  \item
    \(t\) is a \emph{root} of \(S\), that is, it is the unique target contained in $S$ that is not also an input.
  \item
    \(i_1,\ldots,i_k\) are the leaves of \(S\), i.e.~they are the only inputs that are not also targets.
  \item
    Every target in \(S\) is the output of at most one rule in \(S\).
  \end{itemize}

\end{definition}

In other words, a solution of \((B,t,(i_1,\ldots,i_k))\) defines a way (but not necessarily a sequential order) to compute an element of \(T_t\) given elements of \(T_{i_1},\ldots,T_{i_k}\).

\begin{example}[Makefiles as build specifications]
  We can express the data of a build specification in a Makefile-like syntax as follows:

  
\begin{lstlisting}[language=Python]
name_0: name_1, ... name_n
    echo $(f name_1 ... name_n) > name_0
\end{lstlisting}

This can be understood as a genuine Makefile if:

\begin{itemize}
\item
  All the inputs and outputs are ``files;'' that is, \(T_i=\mathtt{File}\) for all \(i\). 
  %
  For the purposes of Make, a \emph{file} can be understood as a tuple \((\mathtt{name},\mathtt{mtime}, \mathtt{data})\).
\item
  \texttt{f} is a shell function.
\item
  Each label appears as the output of at most one step. That is, no step has multiple `providers'.
\end{itemize}

  Recipes in real-life Makefiles (and indeed any build system) are often not pure functions, but rather depend implicitly on some system state whose scope varies on a per-target basis. 
  %
  If one's goal is determinism, all quantities on which the computation actually depends must be listed as explicit inputs.
\end{example}

\begin{example}[Dependencies]

  A specialization of the build specification idea is that of \emph{dependencies} used in package management.
  %
  When installing a package, no explicit function is used to compute the installation of a package from its dependencies; the dependencies simply need to be installed on the system for the package to function.
  %
  Such systems are not rich enough to express a package that `depends on' another in multiple ways.
  %
  Hence, in a dependency specification one expects that there be at most a single task connecting each tuple of input labels to each output label.
  %
  However, a label may still be the target of more than one task.

\end{example}

\begin{example}[DAGs and computation] 
  
  A build specification does not encode a single computation, but rather potentially multiple ways that a particular function can be computed.
  %
  A solution of a build specification is a particular *declaratively specified) computation realising the build.

\end{example}

\paragraph{Multiple providers}
%
Unlike DAGs, our data model is flexible enough to describe builds in which a label can be the target of multiple tasks, each considered as good as any other.
%
In the language of dependency management, our dependency formulae are allowed to contain logical disjunction as well as conjunction.

Disjunctive dependencies are extremely common in practical deployment scenarios such as RPM or DEB-based package management, where objects or configuration fragments listed as a dependency of a given package may have several provider packages, only one of which need be installed to satisfy the dependency.

Naturally, examples of multiple providers in the boot process are also plentiful:

\begin{itemize}
  \item
    The feature \texttt{EFI\_BOOT\_SERVICES} is provided by any UEFI-compliant firmware (for example Tianocore EDK2), but also by any firmware complying with the more stripped-down EBBR specification, such as U-Boot.
  \item
    HTTP and other network drivers are available in UEFI, GRUB, or a Linux initramfs.
  \item
    Common Linux filesystems such as Ext4 and BTRFS each have providers (drivers) in the form of GRUB and Linux modules, but are not available in UEFI.
  \item
    An IP address can be derived either from a static configuration option or via DHCP, either of which itself has several providers spread across different boot stages.
\end{itemize}

\paragraph{Multi-stage builds}

A boot system requires multiple computations that take place at different times and in different contexts. 
%
These stages can be expressed as partial evaluations of a single computation that takes, for example, the development environment, the target device, and the user requirements as input.
%
The targets of the associated build specification may be partitioned into connected components labelled by the build stage during which they are evaluated.

\begin{example}[Caching state to persistent storage] \label{cache}

  Suppose we have a division of a computation into ``build time'' and ``run time.''
  %
  The system must undergo a power cycle between these stages, so they cannot share any memory state.
  %
  Suppose some quantity \texttt{blob} available at build time needs to be made available at run time; it must be cached to persistent storage readable by the run time computer.

  To model this, we posit an $\mathbb{N}$-indexed variable \texttt{storage\_s[]} that tracks the state of all attached persistent storage devices.
  %
  We can consider it as a list of tuples \emph{(device,state)}, where \emph{state} comprises some metadata and a large byte array.
  %
  The build environment provides a driver which yields a handle \texttt{dev\_h} to an attached storage device --- essentially a method table with \texttt{load} and \texttt{save} implementations.
  %
  These can be thought of as returning \emph{commands} to the physical device.
  
  A state update to storage lists as follows:
  \begin{lstlisting}
[
  # build time
  (tx, save, [dev_h, blob, path]),
  (storage_s[1], commit, [storage_s[0], [tx]])
]
  \end{lstlisting}
  We have explicitly noted pre-build \texttt{storage\_s[0]} and post-build \texttt{storage\_s[1]} storage device state.
  
  Then, at runtime we can retrieve it.
  \begin{lstlisting}
[
  # run time
  (q, load, [dev_h_, path]),
  (blob_, query, [storage_s[1], [q]])
]
  \end{lstlisting}
  Note that at run time we have a different instantiation of the device handle \texttt{dev\_h\_}, and possibly even a different \emph{type} of handle if the run and build environments have different driver models.
  %
  Moreover, although we certainly hope that the retrieved value \texttt{blob\_} equals the saved value \texttt{blob}, this property is not guaranteed syntactically --- see \S\ref{security}.

\end{example}


\subsection{Boot sequences as build specifications}

In the following examples, we use the Pythonic notation and explain the typing, for which there are often multiple reasonable approaches, and task descriptions in prose.

How can examples like these be applied in practice?
%
The procedure followed in the examples is:
\begin{itemize}
  \item Mechanistic in nature, and can easily be followed manually by a human programmer with access to the necessary information or even automated;
  \item Provides a clear specification language for boot sequence implementors.
\end{itemize}

\subsubsection{Loading an EFI application} \label{efi-boot}

Suppose we want to boot a system into an EFI application stored as an EFI executable on some removable medium.\footnote{Cf.~\url{https://wiki.osdev.org/UEFI\#UEFI\_applications\_in\_detail}}
%
From a fresh system to a full initialization proceeds in several stages:
%
\begin{enumerate}
  \item \emph{Install firmware.} Build and install firmware to NVRAM.
  \item \emph{Install payload.} Build and install EFI application to bootable media.
  \item \emph{Configure.} Write boot options including target device, partition number, and filesystem path to NVRAM.
  \item \emph{Boot.} Power on the device and, where necessary, capture user input.
\end{enumerate}
%
Specification of these tasks usually fall to different entities:
%
\begin{enumerate}
  \item The OEM usually ships devices with firmware pre-installed.
  \item The user or customer-facing vendor builds and installs the payload.
  \item The user configures the UEFI boot menu.
  \item Firmware developers define the initialization process and handoff.
\end{enumerate}
%
However, in principle there is no reason for this task allocation other than some tasks (such as firmware installation) are generally considered too difficult for ordinary users to pull off.

To describe the process in more detail, we suppose further that the removable drive is a USB drive formatted with a GUID partition table,\footnote{\url{https://uefi.org/specs/UEFI/2.10/05_GUID_Partition_Table_Format.html}} and the EFI application is stored as an EFI executable file on a VFAT-formatted EFI system partition on the drive.
%
Our target is the computation of a full system state \texttt{init}. 

An abstracted, implementation-agnostic form of the boot process might look as follows:
%
\begin{lstlisting}
# EFI application boot, abstract
[
  (init, efi.exec, [payload]),
  (payload, vfat.read, [boot_fs, boot_path]),
  (boot_fs, vfat.mount, [boot_part]),
  (boot_part, gpt.get_part, [boot_dev, boot_partnum]),
  (boot_dev, usb.get, [boot_devpath])
]
\end{lstlisting}
%
In prose, the system needs to be able to:
\begin{enumerate}
  \item Locate, initialize, and obtain a read interface \texttt{boot\_dev} to the USB device.
  \item Parse a GUID partition table and locate a partition \texttt{boot\_part} selected by partition number.
  \item Mount and read from a VFAT filesystem \texttt{boot\_fs} stored on the partition.
  \item Execute an EFI application \texttt{payload} saved on \texttt{boot\_fs} in EFI executable format.
\end{enumerate}
%
The system also needs to be informed values of the leaves of this build specification, that is, the values of \texttt{boot\_path}, \texttt{boot\_partnum}, and \texttt{boot\_devpath}.
%
More precisely, these values need to be recorded somewhere accessible to the early boot environment and in a format understood by the same.

Acknowledging that the values of \texttt{efi.exec} and the other functions in the preceding listing are merely abstract interfaces for which we must provide an implementation (i.e.~a driver), we may rewrite the above as follows:
%
\begin{lstlisting}[name=efi]
# EFI application boot, concrete
[
  (init, apply, [efi.exec, payload]),
  (payload, apply, [vfat.read, boot_fs, boot_path]),
  (boot_fs, apply, [vfat.mount, boot_part]),
  (boot_part, apply, [gpt.get_part, boot_dev, boot_partnum]),
  (boot_dev, apply, [usb.get, boot_devpath])
\end{lstlisting}
%
All of the listed driver functions are now leaves for which we must specify \emph{providers}.
%
Typically, the individual functions will be made available, along with other related functions, as an entry in a function table provided by an associated driver.
%
\begin{lstlisting}[name=efi]
  (efi.exec, get, [Impl(EFI_BOOT_SERVICES)]),
  (vfat.read, get, [Impl(VFAT)]),
  (vfat.mount, get, [Impl(VFAT)]),
  (gpt.get_part, get, [Impl(GPT)]),
  (usb.get, get, [Impl(USB)])
\end{lstlisting}
%
Merging further, multiple standards guarantee implementations of all of the required drivers:
%
\begin{lstlisting}[name=efi]
  (Impl(EFI_BOOT_SERVICES), get, [Impl(UEFI)]),
  (Impl(EFI_BOOT_SERVICES), get, [Impl(EBBR)]),
  ...
\end{lstlisting}
%
This yields our first instance of multiple providers of the same interface.
%
We can continue the same idea by listing multiple implementations:
%
\begin{lstlisting}[firstnumber=22]
  (Impl(EBBR), get, [U-Boot]),
  (Impl(UEFI), get, [EDK2]),
  ...
\end{lstlisting}

Returning to the leaf data, we usually need to obtain the device from some commonly understood string encoding such as a Devicetree path, or possibly bundled together as in a UEFI device path.%\footnote{\url{https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html}}
%
The UEFI specification asks that the boot manager read such paths from a table of options \emph{Boot0000}, \emph{Boot0001}, and so on, in an order defined by the variable \emph{BootOrder}.\footnote{\url{https://uefi.org/specs/UEFI/2.10/03_Boot_Manager.html}}
%
\begin{lstlisting}[firstnumber=30]
  (boot_path, efi.devpath.get_fs_path, [boot_efi_devpath]),
  (boot_partnum, efi.devpath.get_partnum, [boot_efi_devpath]),
  (boot_dev, efi.devpath.get_dev, [boot_efi_devpath]),
  (boot_efi_devpath, select, [fw.efivars.boot, bootnum])
  (bootnum, select, [fw.efivars.bootorder, 0])
]
\end{lstlisting}
%
The new leaves are the EFI variables mentioned above which the user may configure in a firmware configuration utility.
%
A modern boot manager should be able to facilitate this process by scanning available devices and populating the \emph{Boot} array automatically, so that the user need only configure \emph{BootOrder}.


\subsubsection{Loading Linux with a kernel command line} \label{linux-boot}

Suppose now that we wish to load and jump into a Linux kernel from the GRUB boot manager.
%
A typical invocation of a Linux kernel makes use of the following inputs:
%
\begin{enumerate}
\item
  To initialize the state, we need a Linux kernel (a binary blob) and a kernel commandline (a string). 
  %
  The kernel command line may have many arguments, but at the very least it must have a \texttt{root=} argument, which may be one of a few permitted forms.

\item
  If an initramfs is used, as it is for all but the most elementary kernel invocations, we need the initramfs binary blob as well.

\item
  In some cases, the loader may also require a Devicetree blob describing the layout of hardware.
\end{enumerate}
%
We can express this boot na\"ively as follows:
\begin{lstlisting}[name=grub]
  # Initramfs boot with requirements deduced from kernel commandline
  [
    (init, apply, [load, kernel, initramfs, root, args]),
    (load, get, [Impl(Loader)]),
  \end{lstlisting}

In practice, the two or three binary blobs needed to boot are written in advance --- call it ``install time'' --- to a persistent storage medium that the loader can read, as in Example \ref{cache}.
%
The format in which they are written depends on the loader, for example:
%
\begin{itemize}
  \item 
    (GRUB). The kernel and initramfs are made available to the loader by storing them both on some filesystem accessible thereto. In GRUB, this would be the value of the \texttt{\$root} variable.

  \item
    (U-Boot). The kernel, initramfs, and device tree blob are bundled together along with configuration into a unified binary ``FIT'' image.\footnote{\url{https://docs.u-boot.org/en/latest/usage/fit/source_file_format.html}}
\end{itemize}
%
The path or paths to these data are then written, along with the textual metadata (i.e.~kernel command line), into bootloader configuration.

Let us focus our attention now on the case of GRUB, and try to imagine how we might automate the process of identifying a suitable peripheral to use as the GRUB root.
%
A suitable peripheral consists of:
\begin{itemize}
  \item 
    A physical attached device.
    %
    For the purposes of this example, we assume the device is an attached mass storage medium rather than an abstraction such as a network protocol.

  \item
    A GRUB driver for the attached device, either compiled into GRUB or in the form of a dynamically loaded GRUB module.

  \item
    A driver for the attached device available in the build environment, so that the data can be written there at build time.

\end{itemize}
%
The build system must write the kernel and initramfs to such a device and incorporate the associated \texttt{grub\_root} and filesystem paths \texttt{kernel\_path} and \texttt{initramfs\_path} into GRUB's configuration.
%
These values can go either in the main configuration file \emph{grub.cfg} or into separate BLS configuration fragments.\footnote{\url{https://uapi-group.org/specifications/specs/boot\_loader\_specification/\#type-1-boot-loader-specification-entries}}
%
The location of the BLS fragments must then be built into \emph{grub.cfg}.\footnote{These configuration files do not necessarily reside on the same device as \texttt{grub\_root} --- indeed, in x86 Linux systems it is common for them to be located on a different partition.}

Now we can expand the computation executed by GRUB, observing how it provides the leaves \texttt{kernel}, \texttt{initramfs}, \texttt{root}, \texttt{args}, of the fragment listed above and exposes its own leaves \texttt{bls\_path}, \texttt{grub\_root\_path} which must be provided by configuration, and storage state \texttt{storage\_s[1]} (cf.~Example \ref{cache}) which must be prepared by installation.
%
\begin{lstlisting}[name=grub]
  # GRUB runtime
  (Impl(Loader), get, GRUB),
  (kernel, load_kernel, [grub_root_h, storage_s[1], kernel_path]),
  (initramfs, load_initrd, 
      [grub_root_h, storage_s[1], initramfs_path]),
  (root, bls.root, [bls]),
  (args, bls.args, [bls]),
  (kernel_path, bls.kernel_path, [bls]),
  (initramfs_path, bls.initramfs_path, [bls]),
  (bls, load_bls, [grub_root_h, storage_s[1], bls_path]),
  (grub_root_h, load_h, [grub_root_path, grub_root_driver]),
]
\end{lstlisting}
%
We could go further and add new stages ``kernel build time'' and ``initramfs build time,'' expanding the compilation of the kernel and initramfs by deducing driver requirements imposed by the \texttt{root=} kernel argument.


\subsubsection{Multi stage boot}

In all but the simplest scenarios, boots need to go through several stages because the resources needed to fetch the operating system need codecs or drivers not available at the first stage.
%
To illustrate the multiplicity of possibilities, we enumerate here some of the more common elements that may be used to construct a boot.

\begin{enumerate}
  \item Booting a program that resides on a filesystem other than FAT; for example, \texttt{ext4} or \texttt{btrfs}. 
  %
  The target \texttt{btrfs} is provided by either GRUB or Linux, but is not part of the UEFI spec.
  
  \item Booting an ELF executable and not an EFI PE; provided by GRUB or Linux. 
  
  \item Boot a kernel that lives on an attached storage device whose filesystem may be any of a list of supported filesystems. 
  %
  The actual format is autodetected on startup (a dynamic dependency). 
  
  \item Boot a Linux image fetched from a novel storage backend such as Swarm, IPFS, or Arweave.
  %
  Software for the storage backend is available for Linux. 
  %
  In the context of \S\ref{linux-boot}, the client software can be listed as a ``driver'' for the initramfs build.
  
  \item 
    Boot that waits to capture user input interactively (a dynamic dependency).
    %
    Various models allow the user different levels of expressivity:
    \begin{itemize}
      \item Selection from several hardcoded boot options --- provided by UEFI.
      \item Selection from several boot options with an interactive editor to modify them. Dependency is \texttt{grub}.
      \item Shell with various capabilities. Available in UEFI, GRUB, U-Boot, Linux initramfs\ldots{} 
    \end{itemize}
\end{enumerate}

Network boots open up many more dimensions of configurability.

\begin{example}[HTTP boot]

  Fetch an image from the WAN over HTTP with static network configuration. 
  %
  Requires network interface drivers, a TCP/IP stack, and HTTP. 
  
  \begin{enumerate}
  \item Same as above but with HTTPS. 
  %
  In addition to the above you need TLS and root certificates (as trust anchor or with trust derivable from a trust anchor). 
  %
  Typically this would be used with DNS.

  \item HTTP boot but also verifying a PGP signature. 
  %
  Requires a PGP implementation and the signing pubkey (as trust anchor or with trust derivable from a trust anchor). 
  
  \item HTTP boot plus verifying a modern signature scheme with less widespread support, such as BLS with signature aggregation. 
  %
  Dependency is \texttt{bls-verify\ -\textgreater{}\ linux} (probably.) 
  
  \item HTTP boot with network layer autoconfiguration --- a dynamic dependency. 
  %
  Provided by DHCP, DHCPv6, or RA. 
  
  \item HTTP boot, but the image URL is a DNS name rather than an IP address. 
  %
  You need \texttt{dns-client}. If using DHCP, requiers a DHCP client plugin that registers the DNS server address field.
  \end{enumerate}

\end{example}

\newpage
\section{Security} \label{security}

How can we trust boots?
%
To approach the question, we must first make it more precise:
\begin{quote}
  How can we \emph{estimate} and \emph{optimize} the probability that, given a set of assumptions about the environment and the capabilities of an adversary, booting a system puts it into a state with desirable properties?
\end{quote}
The `desirable properties' of the booted system state are our \emph{security objectives}; the capabilities of an adversary are the \emph{threat model}.

A practical boot security framework would provide:
\begin{itemize}
  \item A boot risk management language. A nomenclature for common boot security objectives, assumptions, and threats.
  \item Methods for evaluating risk.
  \item Methods for constrained optimization of risk.
\end{itemize}
For our nomenclature we should draw on the language of firmware and boot loader development practitioners \cite{yao2020building} as well as models associated to the various information security frameworks in use across the industry \cite{taherdoost2022understanding}. 

\begin{remark}
  
  The information security literature abounds with references to mnemonics such as the famous `CIA triad' of information security \emph{confidentiality, availability, integrity} or Microsoft's STRIDE threat model.
  %
  While these mnemonics can be useful for generating rules of thumb, they are generally not expressive enough to accurately model interesting security goals in a given context.

\end{remark}

\subsection{Building a risk model}

In this section, we review standard approaches for formulating \emph{claims} made about software and linking them to trusted \emph{authorities}.
%
We argue that these collectively form ways to build an `outsourced' risk model for initializing a computer system in a given context.
%
It is not always possible to verify the content of claims \emph{in situ}, but with proper infrastructure one can at least verify that the claim has been made, not repudiated, and bound to an authority with known attributes.
%
Given a set of desired properties, risk can then be controlled in a running system by validating claims and disabling specific functionality --- for example, refusing to boot --- in the event of validation failure.

\paragraph{Outsourcing trust}
Some types of security objectives can be efficiently verified by client systems on-the-fly.
%
For example, the \emph{integrity} of a retrieved boot image can be verified at boot time to high confidence against a known hash.

Other objectives are either infeasible to verify locally --- for example, `an adversary with the ability to run unprivileged software cannot achieve a privilege escalation' --- or are informal in nature and cannot in any sense be verified or falsified.
%
When we cannot verify, we need to be able to \emph{trust} boot inputs and processes.
%
This trust is most often inherited from trust in an individual, organization, or brand name --- for example, the authors of a software distribution --- that stands accountable for the good properties of the artefacts.
%
The confidence we can derive from these claims then becomes a function of the nature of the claim and of our trust in the authority's reliability in making such claims.

Hence, to outsource our risk model to a set of claims made by other trusted entities, we would also need an `identity system' comprising:
\begin{itemize}
  \item A scheme for binding identifying attributes, such as common names, to entities, such as natural persons or organisations, that are the subject of trust.
  \item A certification system that binds credentials, such as a public key, with identifying attributes.
  \item A set of authentication methods and accompanying credentials for verifying this binding. 
\end{itemize}
%
Certification and authentication systems can be online or offline.
%
If offline, certificates may ship with an expiry date, and the system may also provide for a highly available \emph{revocation database} that security-conscious systems should query as part of the authentication process.

Examples of such systems:
\begin{itemize}
  \item
    Probably the most widespread system in use is the Internet public key infrastructure (PKI) based on X.509 certificates \cite{rfc5280}.
    %
    The process for binding entities to their identities is described by a CA's \emph{Certification Practice Statement} (CPS).
    %
    PKI and its relation to other classical certification methods such as PGP's web of trust (WoT) model are discussed in \cite{gerck1997overview}.
    %
    PKI provides for revocation either through certificate revocation lists (CRLs) as introduced in RFC-5280, the newer Online Certificate Status Protocol (OCSP), or browser-specific solutions \cite{crlsets}.

  \item 
    JSON web tokens \cite{rfc7519} provides an authenticated scheme to bind attributes, called \emph{claims} in this context, to keys (certification). 
    %
    IANA maintains a list of recognized claim schemata.\footnote{\url{https://www.iana.org/assignments/jwt/jwt.xhtml}}

  \item
    Decentralized identifiers (DIDs) provide a way to communicate and validate authentication material.\footnote{\url{https://www.w3.org/TR/did-core/}}
    %
    The handling of certification and name binding tasks is left up to the individual DID methods.

\end{itemize}
%
In recent years there is also substantial interest in using the highly available timestamping properties of blockchains to provide name-binding or PKI services \cite{eip137,tomsguide2023proton}.


\paragraph{Claims about artefacts} Given an adequate system for identifying the creators of claims, we need a common language and taxonomy for the content of the claims.
%
We recommend adoption of the language of the SCITT working group \cite{ietf-scitt-architecture-04}.\footnote{\url{https://datatracker.ietf.org/wg/scitt/about/}}

Here are some examples of claims about generic software distributions:
\begin{itemize}
  \item Claim that a software distribution has been published under a certain product name by an owning entity.
  \item Existence or non-existence of registered vulnerabilities, for example in the form of CVE records.\footnote{\url{https://www.cve.org/}}
  \item Existence and claims of audits bound to a specific software version. This idea has been floated several times in the context of smart contract deployments.
  \item Claim that a program or library implements a certain interface or fulfils a certain contract.
  \item Claims of concrete security guarantees in a given context and threat model.
\end{itemize}
%
Further examples can be found in the use cases report of the SCITT WG \cite{ietf-scitt-software-use-cases-02}.

More relevant to the present paper, we may wish to claim that an operating system distribution image is bootable via a stated boot process, or a boot process with certain properties.
%
For instance:
\begin{itemize}
  \item Statement of format of the image (raw partition, raw GPT-formatted partitioned disk with EFI system partition) and entry point to the boot process (EFI system partition, explicit start vector)
  \item List of components used in the boot process.
  \item Boot computation specification in the sense of \S\ref{build}.
  \item Contract implemented between bootloader and payload.
  \item Preservation of privilege level between boot stages, in cases where these are distinguished.
  \item Boot loader makes use of secure hardware services such as TPM.
\end{itemize}
%


\subsection{Example: integrity/tampering boot security problem}

The most widely discussed security goal of a boot sequence is the \emph{integrity} of boot images as measured against a commitment made by a trusted authority or the operator himself.

\begin{example}[U-Boot standard boot]

  \emph{Context.} An ARM SoC with (trusted) U-Boot firmware is booting a FIT
  image,\footnote{\url{https://u-boot.readthedocs.io/en/latest/usage/fit/source_file_format.html}} comprising a kernel, initramfs, device tree blob, and kernel commandline.
  %
  The image is written to an SD card by the operator (cf.~Example \ref{cache}).

  \emph{Adversary.} May modify the contents of the SD card after the user writes it but before booting.

  \emph{Security goal.} Either the specified FIT image is booted, or the boot fails and the system halts.


  In terms of build specifications, the invariant being verified here is the equality of the installed image and the retrieved image.
  %
  In the notation of Example \ref{cache}, we are ensuring \texttt{blob==blob\_} in the presence of an adversary that can modify the post-installation storage state \texttt{storage\_s[1]}.

  For more practical information on this example, see \cite{timesys2023securing}.

\end{example}


\begin{example}[Traditional package management] \label{package-management}

  A typical package management scenario is that a user wishes to download and install a software release associated with a particular project name.

\emph{Context.} A user retrieves a software distribution package from a remote repository.

\emph{Adversary.} May modify data in transit and at rest on the remote repository. May impersonate the remote repository at the IP level.

\emph{Security goal.} The retrieved package is the desired official release of the named project.

Abstractly, the risks associated with this security goal can be controlled as follows:
\begin{enumerate}
  \item 
    An identity service is used to bind the project name to an authentication method $x$ (for example, issuing a DID).
  \item 
    At the social layer, a claim format is agreed upon that specifies
    \begin{itemize}
      \item A commitment to a package artefact.
      \item A release number.
    \end{itemize}
    An $x$-authenticated claim in this format is considered to vouch that the artefact to which the claim commits is the stated release of the named project.
  \item 
    Upon retrieval, the client establishes a trust relationship with the identity provider, verifies the authentication data, and measures the retrieved artefact against the authenticated commitment.
    %
    If any of these three validation stages fails, the retrieval fails and emits an explanatory log message.

  \end{enumerate}
  Concretely these checks are implemented with some standard technologies.
  \begin{enumerate}
  \item
    In widely used package repositories, a package is accompanied by a commitment in the form of a checksum or hash (e.g.~SHA256), and a PGP signature of that commitment.
    %
    The signing public key can be attached to an identity service in various ways, for example by registration on a PGP keyserver or by association with a TLS certificate.

  \item
    The claim format is defined as an OpenPGP message with Signature Type byte $0x00$ \cite[\S5.2.1]{rfc4880} which provides for an interpretation where the signer is the `author' or `owner' of the signed artefact.\footnote{\url{https://www.rfc-editor.org/rfc/rfc4880.html\#section-5.2.1}}

  \item
    Suppose that the signing key has been associated with an identity using an X.509 certificate (for example, by using the same keypair to sign the certificate request, or by publishing the public key on an appropriately website served with HTTPS).
    %
    Trust in this identity is then derived from validating a certificate chain leading to a trusted root certificate authority (CA), whose certificates are installed in advance to form a trust anchor.

    The user wishing to have the highest possible `liveness' guarantees for the identity verification must connect to an online service to check certificate revocation status.

  \end{enumerate}

\end{example}

\begin{example}[Secure boot]

  Microsoft's Secure Boot technology is based on essentially the same model as Example \ref{package-management}.\footnote{\url{https://uefi.org/specs/UEFI/2.10/32_Secure_Boot_and_Driver_Signing.html\#firmware-os-key-exchange-creating-trust-relationships}}
  %
  Thus the user wishes to boot a system whose boot image and hardware devices, as viewed from the context of UEFI firmware, are subject to `approval' by the authority of the platform owner.
  %
  The platform owner's identity is bound to a \emph{platform key} by the fact of its enrolment in platform firmware, and its authority can be delegated by the enrolment of additional \emph{key exchange keys}.

  The `approval' claim for an EFI executable image is encoded as an X.509 certificate appended to the end of the image.
  %
  Trust in the `identity' of keys enrolled in the platform firmware is implicit in the use of the platform.

  This system has a number of limitations:
  \begin{itemize}
    \item
      The lack of a flexible identity service makes it difficult for users to take control of their boot environment by registering their own authentication material to vouch for boot programs.
      %
      Instead, one must derive trust in practice from keypairs owned by Microsoft.\footnote{https://www.rodsbooks.com/efi-bootloaders/secureboot.html}

    \item 
      Because the system cannot necessarily be expected to connect to the Internet at a very early stage in the boot sequence, identity and claim revocation status must be stored directly in firmware configuration.
      %
      Since firmware configuration must usually reside in an extremely constrained storage component, this leads to some difficulties not visible at the OS level.\footnote{\url{https://github.com/rhboot/shim/blob/main/SBAT.md}}
    
    \item
      The scope of secure boot is limited to measured device driver loading and handoff between platform firmware and an EFI application.
      %
      It cannot make claims about the loading of platform firmware itself, or about the subsequent payload of the bootloader.
      
  \end{itemize}
\end{example}

\begin{example}[Abstract integrity check]

  In the data model outlined in \S\ref{build}, a generic integrity problem can be expressed as follows:
  
  \emph{Context.} A user wants to compute a target \(t\) of a build \(B\) in several stages \(S_1,\ldots,S_n\). At each stage, some inputs are consumed and some intermediate targets \(t'\) are computed.
  
  \emph{Adversary.} Between each stage, the (tampering) adversary may modify the value of the intermediate targets \(t'\).
  
  \emph{Security goal.} The result of the computation is either the true value of \(t\) or \(\bot\), indicating failure.

  The probability of achieving the security goal can be increased by storing and retrieving succinct commitments to the intermediate values whose integrity may be compromised.

\end{example}


\section{Conclusion}

We have described a powerful and flexible declarative language in which the various early initialization stages for physical machines can be couched, even when few logical abstractions are available.
%
When fully developed, this type of approach can facilitate both innovation in boot sequence design, by empowering developers, and security risk modelling, by defining explicit components which are prone to analogy and generalization and about which security claims can be made.
%
Future work should pursue actual implementation of automated boot sequence solutions following the declarative paradigm, and discover commonalities between security contexts and relate them to boot definition structure.

The security considerations discussed here mostly apply to all software distribution patterns, and not only to bare metal machine initialization.
%
We advocate for community initiatives to encourage developers to make more precise claims about their software artefacts, study the effect of composing security claims, and provide highly available and timestamped infrastructure to register them.
%
% and to improve community understanding of the guarantees provided by different identity services --- namely, name-binding, certification, and authentication.

\printbibliography