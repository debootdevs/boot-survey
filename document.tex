% DOCUMENT BODY
\maketitle

%\tableofcontents

\begin{abstract}

  We consider bootstrapping computers, also known as bare metal provisioning, in a more general context of deployments and dependent builds. We review the state of the art, exhibit a functional programming inspired data model that expresses builds declaratively and specialize it to a boot context, and discuss the need for and components of a trust-oriented security model for provisioning.

\end{abstract}

\section{Introduction}

Booting computers has long been a somewhat neglected corner of IT infrastructure. 
%
It is often easy to ignore the sequence of unfamiliar and usually poorly documented ephemeral stages a computer quickly steps through between a power cycle and normal operation. 
%
Indeed, one usually expects that a correctly configured system spends only a tiny fraction of its life cycling through these stages.

Despite this, there are a few reasons one may wish to expend attention on the bootloader. 
%
Paramount among these is \emph{security.} 
%
In order to evaluate the security of the software supply chain deployed in a computer system, one must trace the root of trust all the way to the beginning of a power cycle.
%
This entails careful formulation and analysis of the security properties preserved during the execution and handoff of each stage of the boot sequence.

A second, related issue is \emph{determinism}, that is, the idea that the same boot process configuration will yield the same system state transition regardless of context.
%
To this end, both compilation and building of the deployed software and execution of initialization code must be reproducible from a clear task description that makes all inputs explicit.

\begin{remark}
  
  Clearly, it is neither practical nor desirable for system state to be literally immutable, or reproducible: at the very least, we expect that the machine clock ticks on, IP traffic is processed, logs accumulate, and the state of stateful software evolves whle the machine is operational.

  A simple view on determinism asks only that the configuration and software installed on a system together with the set of active services be reproducible.
  %
  In a Linux environment, this might mean invariance of the contents of the $\mathtt{/boot}$, $\mathtt{/etc}$, and $\mathtt{/usr}$ trees.

\end{remark}

We think the bootloader is overdue a modern theoretical treatment. 
%
In this article we address the question:
\begin{quote}
  What type of thing is a boot sequence?
\end{quote}
%
An answer to this question empowers us to draw analogies with other types of computation and make more precise and interpretable security claims.
%
A well-defined data model for defining boot sequences can have a number of benefits:

\begin{itemize}
\tightlist
\item
  \emph{Accessibility.} A modern, implementation-agnostic description language means more users understanding and taking control of their own boot sequences.
\item
  \emph{Security.} A serialized boot definition can be used as a part of a \emph{software bill of materials} which is the subject of security claims about a deployment.
\item
  \emph{Extensibility.} The present obscure state of documentation makes it difficult for developers to integrate new technologies such as novel storage backends early in the boot process.
\end{itemize}

The second question we address in this article is:
\begin{quote}
  How can boots be trusted?
\end{quote}

The answers to these questions cannot be divorced from one another.
%
In order to make trustworthy claims about boots, we have to be able to clearly state the subject of the claims.
%
On the other hand, a formal definition of a boot cannot have much practical significance if users cannot be sure that the state reached by their system matches the definition.

In \S\ref{build} we introduce a data model for defining computations and exhibit how typical boot sequence paradigms can be expressed in this model.
%
In \S\ref{security} we discuss elements that would be needed for a formal cybersecurity framework and review some ubiquitous examples with this in mind.


\subsection{Related work}\label{related-work}

For a thorough engineering overview of the structure of boot processes at the firmware level, see \cite{yao2020building}.

There are many cross-industry initiatives to develop standards associated to the boot process:
\begin{itemize}
  \item
   The \emph{Universal Extensible Firmware Interface} (UEFI) is a set of cross-platform standards for an execution environment presented by platform firmware which early stage boot manager or bootloader software can hook into.\footnote{\url{https://uefi.org/specifications}}

  \item
    The \emph{Preboot Execution Environment} (PXE, pronounced `pixie') is a component of the UEFI specification that defines a protocol, based on DHCP and TFTP, for negotiating a network boot.
    %
    It is the standard way to load the next stage after platform firmware over a network, although some systems also offer boot from a webserver.

  \item
    The \emph{Extended Bootloader Base Requirements} (EBBR) are a subset of UEFI designed as a specification compatible with U-Boot, the industry standard firmware and bootloader implementation for embedded systems.\footnote{\url{https://arm-software.github.io/ebbr/}}

  \item
    The \emph{multiboot} specification and its sequel does some work to define the format of OS kernel loaders. 
    %
    Unlike the preceding examples, multiboot does not attempt to specify how systems should operate at the platform firmware level --- its scope is limited to starting an OS.
    %
    The reference implementation of a multiboot-compliant host is the GRUB boot manager, widely used in booting Linux or BSD on x86 computers (although Linux and BSD are not usually distributed as a multiboot-compliant client!)

  \item
    The \emph{boot loader specification} project defines disk formats, file formats, and naming conventions for boot loader menu entries.\footnote{\url{https://uapi-group.org/specifications/specs/boot_loader_specification/}} 
    %
    BLS-compliant menu entry configurations are intended to be OS-agnostic and can be thought of as a data model for a kernel loader boot stage.
    %
    However, boots defined in this format are limited to ones where the boot artifacts are located on local storage, which must be partitioned in one of a few pre-defined layouts. 
    %
    Thus \emph{extensibility} cannot be said to be one of the goals of the project.

\end{itemize}

Applications designed for bare-metal provisioning of fleets of devices in data centres must define their own data model for specifying deployments.
%
Generally speaking, these systems operate over a network (hence use network-based boot protocols, the major one being PXE) and are opinionated about the structure of boot flow.
%
Some examples are OpenStack's \emph{Ironic},\footnote{\url{https://wiki.openstack.org/wiki/Ironic}}, Canonical's \emph{MaaS},\footnote{\url{https://maas.io}}, and Equinix's \emph{Tinkerbell}.\footnote{\url{https://tinkerbell.org/}}

The OpenStack authors have written on the need for a standardized bare metal provisioning API \cite{openstack2023building}.

The early boot and system initialization standards are accompanied by standards defining data models and serialization formats for hardware devices.
%
These models aggregate the addressing systems of various bus types (e.g. PCI) into a single namespace.
%
As well as providing essential input data for boot loaders to discover and initialize peripherals, a path-like serialization format is useful for specifying the location of boot images and configuration in boot definitions.
\begin{itemize}
  \item
    The UEFI specification includes a systematic and quite general language of \emph{devpaths} for defining \emph{locations} for sourcing images.\footnote{\url{https://uefi.org/specs/UEFI/2.10/10\_Protocols\_Device\_Path\_Protocol.html}}

    The \emph{Advanced Configuration and Power Interface} (ACPI), also maintained by the UEFI Forum. Generally something employed at the OS level but which is available to UEFI.
    
  \item
    Devicetree.\footnote{\url{https://www.devicetree.org/}}
\end{itemize}

Regarding reproducibility, the subject of \emph{reproducible builds} in software distribution has already received a fair amount of attention \cite{lamb:hal-03196519} (https://hal.science/hal-03196519/, https://reproducible-builds.org).
  
  The latter is clearly related in spirit to the idea of \emph{immutable infrastructure}.
  %
  This term is commonly used to refer to the phoenix server model,\footnote{} where servers are redeployed from scratch --- in particular, including a power cycle --- whenever an upgrade is requested.
  %
  If deployments from scratch are reproducible, then this system ensures that upgrades are reproducible too.

  But for a deployment to be reproducible, every stage of the deployment should also be reproducible; with a suitable system for caching intermediate states that remain invariant on an upgrade, reproducibility can be achieved without a phoenix server model.


\section{Boots as builds} \label{build}

A boot can be regarded as a set of steps to compute the state of an initialized system. 
%
In some cases, recomputing the value with updated inputs (i.e.~rebooting) can be accelerated using a caching strategy, so that a reboot may occur without necessarily going through a full power cycle.
%
In some cases, the requirements to launch a boot stage can be provided by more than one environment, so that the same target can be reached in multiple ways.

In \S\ref{data-model}, we define a data model rich enough to specify describing builds with multiple valid routes to the target.
%
Subsequently, we show several ways to express some common boot pathways in this model.

\subsection{Data model} \label{data-model}

\begin{definition}
  
  An \emph{n-ary operation} from types \((T_1,\ldots,T_n)\) to type \(T_0\) is defined to be a function \(f:\prod_{i=1}^n T_i \rightarrow T_0\).\footnote{For the purposes of this paper, a `type' can be understood as a set.}
  %
  Note that the (single) output and inputs of an \(n\)-ary operation are indexed together, in that order, by \([n]:=\{0,\ldots,n\}\).

  A \emph{task} is an operation \(f\) of any arity \(n\) together with a labelling \(\mathtt{name}:[n]\rightarrow \mathtt{String}\) of the inputs and output by strings and a ``task description,'' which should be an explicit expression of some $n$-ary operation comprehensible in the context in which the task will be used.
  %
  The label \(\mathtt{name}(0)\) of the output of the operation is called the \emph{target} of the task.

  A \emph{build specification} or simply \emph{build} is a set of tasks.

\end{definition}

Expressed in a Python-like pseudocode, the data schema looks something like the following:

\begin{lstlisting}
[
  (name_0, f, [name_1, ..., name_n]),
  ...
]
\end{lstlisting}

In this picture, the task description would be a Python function and the labelled source and destination types are denoted by (typed) named variables.\footnote{This is purely illustrative and is certainly not supposed to
suggest a bootloader implemented in Python!}

Or a more precisely specced JSON

\begin{comment}
\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{[}
    \FunctionTok{\{}
        \DataTypeTok{"target"}\FunctionTok{:} \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_0"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_0"}\FunctionTok{\},}
        \DataTypeTok{"inputs"}\FunctionTok{:} \OtherTok{[}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_1"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_1"}\FunctionTok{\}}\OtherTok{,}
            \ErrorTok{...}\OtherTok{,}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_n"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_n"}\FunctionTok{\}}\OtherTok{,}
        \OtherTok{]}\FunctionTok{,}
        \DataTypeTok{"task"}\FunctionTok{:} \ErrorTok{@td}
    \FunctionTok{\}}\OtherTok{,}
    \ErrorTok{...}
\OtherTok{]}
\end{Highlighting}
\end{Shaded}
\end{comment}

\begin{lstlisting}
[
  {
    "target": {"label": "name_0", "type": "T_0"},
    "inputs": [
      {"label": "name_1", "type": "T_1"},
      ...,
      {"label": "name_n", "type": "T_n"},
    ],
    "task": @td
  },
  ...
]
\end{lstlisting}

Here \texttt{@td} should be some task description schema whose details we leave unspecified.

\begin{definition}
  Let \(B\) be a build and \(t\) a target of \(B\), and \((i_1,\ldots,i_k)\) a set of labels. 
  %
  A \emph{solution} of \((B,t,(i_1,\ldots,i_k))\) is a subset \(S\) of \(B\) such that:

  \begin{itemize}
  \item
    \(t\) is a \emph{root} of \(S\), that is, it is the unique target that is not also an input.
  \item
    \(i_1,\ldots,i_k\) are the leaves of \(S\), i.e.~they are the only inputs that are not also targets.
  \item
    Every target in \(S\) is the output of at most one rule in \(S\).
  \end{itemize}

\end{definition}

In other words, a solution of \((B,t,(i_1,\ldots,i_k))\) defines a way to compute an element of \(T_t\) given elements of \(T_{i_1},\ldots,T_{i_k}\).

\begin{example}[Makefiles as build specifications]
  We can express the data of a build specification in a Makefile-like syntax as follows:

  
\begin{lstlisting}[language=Python]
name_0: name_1, ... name_n
    echo $(f name_1 ... name_n) > name_0
\end{lstlisting}

This can be understood as a genuine Makefile if:

\begin{itemize}
\item
  All the inputs and outputs are ``files;'' that is, \(T_i=\mathtt{File}\) for all \(i\). 
  %
  For the purposes of Make, a \emph{file} can be understood as a tuple \((\mathtt{name},\mathtt{mtime}, \mathtt{data})\).
\item
  \texttt{f} is a shell function.
\item
  Each label appears as the output of at most one step. That is, no step has multiple `providers'.
\end{itemize}

  Recipes in real-life Makefiles (and indeed any build system) are often not pure functions, but rather depend implicitly on some system state whose scope varies on a per-target basis. 
  %
  If one's goal is determinism, all quantities on which the computation actually depends must be listed as explicit inputs.
\end{example}

\begin{example}[Dependencies]

  A specialization of the build specification idea is that of \emph{dependencies} used in package management.
  %
  When installing a package, no explicit function is used to compute the installation of a package from its dependencies; the dependencies simply need to be installed on the system for the package to function.
  %
  Such systems are not rich enough to express a package that `depends on' another in multiple ways.
  %
  Hence, in a dependency specification one expects that there be at most a single task connecting each tuple of input labels to each output label.

\end{example}

\begin{example}[DAGs and computation] 
  
  A build specification does not encode a single computation, but rather potentially multiple ways that a particular function can be computed.
  %
  A solution of a build specification is a particular computation realising the build.

\end{example}

\paragraph{Multiple providers}
%
Unlike DAGs, our data model is flexible enough to describe builds in which a label can be the target of multiple tasks, each considered as good as any other.
%
In the language of dependency management, our dependency formulae are allowed to contain logical disjunction as well as conjunction.

Disjunctive dependencies are extremely common in practical deployment scenarios such as RPM or DEB-based package management, where objects or configuration fragments listed as a dependency of a given package may have several provider packages, only one of which need be installed to satisfy the dependency.

Naturally, examples of multiple providers in the boot process are also plentiful:

\begin{itemize}
  \item
    The feature \texttt{EFI\_BOOT\_SERVICES} is provided by any UEFI-compliant firmware (for example Tianocore EDK2), but also by any firmware complying with the more stripped-down EBBR specification, such as U-Boot.
  \item
    HTTP and other network drivers are available in UEFI, GRUB, or a Linux initramfs.
  \item
    Common Linux filesystems such as Ext4 and BTRFS each have providers (drivers) in the form of GRUB and Linux modules, but are not available in UEFI.
  \item
    An IP address can be derived either from a static configuration option or via DHCP, either of which itself has several providers spread across different boot stages.
\end{itemize}

\paragraph{Multi-stage builds}

A boot system requires multiple computations that take place at different times and in different contexts. 
%
These stages can be expressed as partial evaluations of a single computation that takes, for example, the development environment, the target device, and the user requirements as input.
%
The targets of the associated build specification may be partitioned into connected components labelled by the build stage during which they are evaluated.

\subsection{Boot sequences as build specifications}

In the following examples, I use the Pythonic notation and explain the typing, for which there are often multiple reasonable approaches, and task descriptions in prose.

How can examples like these be applied in practice?
%
The procedure followed in the examples is:
\begin{itemize}
  \item Mechanistic in nature, and can easily be followed manually by a human programmer with access to the necessary information or even automated;
  \item Provides a clear specification language for boot sequence implementors.
\end{itemize}

\subsubsection{Loading an EFI application}

Suppose we want to boot a system into an EFI application stored as an EFI executable on some removable medium.\footnote{Cf.~\url{https://wiki.osdev.org/UEFI\#UEFI\_applications\_in\_detail}}
%
From a fresh system to a full initialisation proceeds in several stages:
%
\begin{enumerate}
  \item \emph{Install firmware.} Build and install firmware to NVRAM.
  \item \emph{Install payload.} Build and install EFI application to bootable media.
  \item \emph{Configure.} Write boot options including target device, partition number, and filesystem path to NVRAM.
  \item \emph{Boot.} Power on the device and, where necessary, capture user input.
\end{enumerate}
%
Specification of these tasks usually fall to different entities:
%
\begin{enumerate}
  \item The OEM usually ships devices with firmware pre-installed.
  \item The user or customer-facing vendor builds and installs the payload.
  \item The user configures the UEFI boot menu.
  \item Firmware developers define the initialization process and handoff.
\end{enumerate}
%
However, in principle there is no reason for this task allocation other than some tasks (such as firmware installation) are generally considered too difficult for ordinary users to pull off.

To describe the process in more detail, we suppose further that the removable drive is a USB drive formatted with a GUID partition table, and the EFI application is stored as an EFI executable file on a VFAT-formatted EFI system partition on the drive.
%
Our target is the computation of a full system state \texttt{init}. 

An abstracted, implementation-agnostic form of the boot process might look as follows:
%
\begin{lstlisting}
# EFI application boot, abstract
[
  (init, efi.exec, [payload]),
  (payload, vfat.read, [boot_fs, boot_path]),
  (boot_fs, vfat.mount, [boot_part]),
  (boot_part, gpt.get_part, [boot_dev, boot_partnum]),
  (boot_dev, usb.get, [boot_devpath])
]
\end{lstlisting}
%
In prose, the system needs to be able to:
\begin{enumerate}
  \item Locate, initialize, and obtain an read interface to the USB device.
  \item Parse a GUID partition table and locate a partition selected by partition number.
  \item Mount and read from a VFAT filesystem.
  \item Execute an EFI application in EFI executable format.
\end{enumerate}
%
The system also needs to be informed values of the leaves of this build specification, that is, the values of \texttt{boot\_path}, \texttt{boot\_partnum}, and \texttt{boot\_devpath}.
%
More precisely, these values need to be recorded somewhere accessible to the early boot environment and in a format understood by the same.

Acknowledging that the values of \texttt{efi.exec} and the other functions in the preceding listing are merely abstract interfaces for which we must provide an implementation (i.e.~a driver), we may rewrite the above as follows:
%
\begin{lstlisting}[name=efi]
# EFI application boot, concrete
[
  (init, apply, [efi.exec, payload]),
  (payload, apply, [vfat.read, boot_fs, boot_path]),
  (boot_fs, apply, [vfat.mount, boot_part]),
  (boot_part, apply, [gpt.get_part, boot_dev, boot_partnum]),
  (boot_dev, apply, [usb.get, boot_devpath])
\end{lstlisting}
%
All of the listed driver functions are now leaves for which we must specify \emph{providers}.
%
Typically, the individual functions will be made available, along with other related functions, as an entry in a function table provided by an associated driver.
%
\begin{lstlisting}[name=efi]
  (efi.exec, get, [Impl(EFI_BOOT_SERVICES)]),
  (vfat.read, get, [Impl(VFAT)]),
  (vfat.mount, get, [Impl(VFAT)]),
  (gpt.get_part, get, [Impl(GPT)]),
  (usb.get, get, [Impl(USB)])
\end{lstlisting}
%
Merging further, multiple standards guarantee implementations of all of the required drivers:
%
\begin{lstlisting}[name=efi]
  (Impl(EFI_BOOT_SERVICES), get, [Impl(UEFI)]),
  (Impl(EFI_BOOT_SERVICES), get, [Impl(EBBR)]),
  ...
\end{lstlisting}
%
This yields our first instance of multiple providers of the same interface.
%
We can continue the same idea by listing multiple implementations:
%
\begin{lstlisting}[firstnumber=22]
  (Impl(EBBR), get, [U-Boot]),
  (Impl(UEFI), get, [EDK2]),
  ...
\end{lstlisting}

Returning to the leaf data, we usually need to obtain the device from some commonly understood string encoding such as a Devicetree path, or possibly bundled together as in a UEFI device path.\footnote{\url{https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html}}
%
The UEFI specification asks that the boot manager read such paths from a table of options \emph{Boot0000}, \emph{Boot0001}, and so on, in an order defined by the variable \emph{BootOrder}.\footnote{\url{https://uefi.org/specs/UEFI/2.10/03_Boot_Manager.html}}
%
\begin{lstlisting}[firstnumber=30]
  (boot_path, efi.devpath.get_fs_path, [boot_efi_devpath]),
  (boot_partnum, efi.devpath.get_partnum, [boot_efi_devpath]),
  (boot_dev, efi.devpath.get_dev, [boot_efi_devpath]),
  (boot_efi_devpath, select, [fw.efivars.boot, bootnum])
  (bootnum, select, [fw.efivars.bootorder, 0])
]
\end{lstlisting}
%
The new leaves are the EFI variables mentioned above which the user may configure in a firmware configuration utility.
%
A modern boot manager should be able to facilitate this process by scanning available devices and populating the \emph{Boot} array automatically, so that the user need only configure \emph{BootOrder}.


\subsubsection{Loading Linux with a kernel command line}

A typical invocation of a Linux kernel makes use of the following inputs:
%
\begin{enumerate}
\item
  To initialize the state, we need a Linux kernel and a kernel commandline. 
  %
  The kernel command line must at least have a \texttt{root=} argument. 
  %
  If an initramfs is used, we also need the underlying data for that as well as the corresponding command line argument. 
\item
  The kernel and initramfs have type \(\mathbb{B}^\star\),
  %
  The other leaves \texttt{root} and \texttt{extra\_params} have type \(\mathtt{String}\).
\item
  If the bootloader also has to fetch \texttt{vmlinuz} from a peripheral
  (i.e.~it is not already assumed to reside in a hardcoded location),
  then we can add a fetch stage for that too. The type of the input
  \texttt{kernel-path} should depend on the environment and available
  drivers for fetching. For example, if the implicit context is GRUB,
  \texttt{kernel-path} should be typed as a
  \href{https://www.gnu.org/software/grub/manual/grub/grub.html\#Naming-convention}{GRUB
  path}.
\end{enumerate}

\begin{lstlisting}
# Initramfs boot with requirements deduced from kernel commandline
[
  (init, apply, [loader, kernel, initramfs, root, args]),
  (initramfs, build, [kernel_modules, root]),
]
\end{lstlisting}

The leaves of the build are \texttt{loader}, \texttt{kernel}, \texttt{root}, and \texttt{args}. 
%
The \texttt{initramfs} target is computed a build time and cached on a boot medium.
%
The expanded computation is
\begin{lstlisting}
# Initramfs boot with requirements deduced from kernel commandline
[
  (init, apply, [loader, kernel, initramfs, root, args]),
  (kernel, read, [boot_fs[1], kernel_path]),
  (initramfs, read, [boot_fs[1], initramfs_path]),
  (boot_fs[1], write, [initramfs, initramfs_path, boot_fs[0]]),
  (initramfs, build, [kernel_modules, root]),
]
\end{lstlisting}
%
The runtime leaves \texttt{kernel\_path}, \texttt{initramfs\_path}, and \texttt{root}+\texttt{args} are exactly the data to be found in a typical Linux boot option configuration.\footnote{\url{https://uapi-group.org/specifications/specs/boot\_loader\_specification/\#type-1-boot-loader-specification-entries}}
%
We attach a counter to the handle \texttt{boot\_fs} to indicate that the write operation alters the state of the device to which it mediates access.


\subsubsection{Multi stage boot}

In all but the simplest scenarios, boots need to go through several stages because the resources ne ed to fetch the operating system need codecs or drivers not available at the first stage.

Typically, the full computation falls into several stages:
\begin{enumerate}
  \item \emph{Build.} Build and install platform firmware and bootloader.
  \item \emph{Configure.} Build kernel, initramfs containing relevant rootfs drivers, and userspace, and configure kernel loading, including kernel command line.
  \item \emph{Run.} Capture runtime user interaction and compute system initialization state.
\end{enumerate}

\begin{enumerate}
  \item Booting a program that resides on a filesystem other than FAT; for example, \texttt{ext4} or \texttt{btrfs}. 
  %
  The target \texttt{btrfs} is provided by either GRUB or Linux.
  %
  Similarly, the kernel is an ELF executable and not an EFI PE; this is also provided by GRUB or Linux. 
  
  \item Boot a kernel that lives on an attached storage device whose filesystem may be any of a list of supported filesystems. 
  %
  Which one it is is autodetected on startup (a dynamic dependency). 
  
  \item Boot an image fetched from novel store (Swarm, IPFS, Arweave\ldots) that has been developed for a full OS, e.g.~Linux, BSD, MacOS, Windows. 
  %
  Your dependency is that OS and an init process that launches the client for the novel protocol.
  
  \item 
    You want to capture user input interactively --- a dynamic dependency.
    %
    \begin{itemize}
      \item Selection from several hardcoded boot options --- provided by UEFI.
      \item Selection from several boot options with an interactive editor to modify them. Dependency is \texttt{grub}.
      \item Shell with various capabilities. Available UEFI, GRUB, Linux+initramfs\ldots{} 
    \end{itemize}
    


\end{enumerate}

\begin{example}[HTTP boot]

  Fetch an image from the WAN over HTTP with static network configuration. 
  %
  Requires network interface drivers, a TCP/IP stack, and HTTP. 
  
  \begin{enumerate}
  \item Same as above but with HTTPS. 
  %
  In addition to the above you need TLS and root certificates (as trust anchor or with trust derivable from a trust anchor). 
  %
  Typically this would be used with DNS.

  \item HTTP boot but also verifying a PGP signature. 
  %
  Requires a PGP implementation and the signing pubkey (as trust anchor or with trust derivable from a trust anchor). 
  
  \item HTTP boot plus verifying a modern signature scheme with less widespread support, such as BLS with signature aggregation. 
  %
  Dependency is \texttt{bls-verify\ -\textgreater{}\ linux} (probably.) 
  
  \item HTTP boot with network layer autoconfiguration --- a dynamic dependency. 
  %
  Provided by DHCP, DHCPv6, or RA. 
  
  \item HTTP boot, but the image URL is a DNS name rather than an IP address. 
  %
  You need \texttt{dns-client}. If using DHCP, requiers a DHCP client plugin that registers the DNS server address field.
  \end{enumerate}

\end{example}

\section{Security} \label{security}

How can we trust boots?
%
To approach the question, we must first make it more precise:
\begin{quote}
  How can we \emph{estimate} and \emph{optimize} the probability that, given a set of assumptions about the environment and the capabilities of an adversary, booting a system puts it into a state with desirable properties?
\end{quote}
The `desirable properties' of the booted system state are our \emph{security objectives}; the capabilities of an adversary are the \emph{threat model}.

A practical boot security framework would provide:
\begin{itemize}
  \item A boot risk management language. A nomenclature for common boot security objectives, assumptions, and threats.
  \item Methods for evaluating risk.
  \item Methods for constrained optimization of risk.
\end{itemize}
For our nomenclature we should draw on the language of firmware and boot loader development practitioners \cite{yao2020building} as well as the models associated to the various information security frameworks in use across the industry \cite{taherdoost2022understanding}. 
%
Here is a short list to get us started:
\begin{itemize}
  \item Security goals: Information security's famous `CIA triad' of \emph{confidentiality, availability, integrity}, and possible extensions, e.g.~\emph{authentication, non-repudiation}.
  \item The STRIDE threat model. Attack trees.
  \item Secure boot
  \item TPM. Measurements.
  \item Identity, a.k.a.~binding key material to an identifier or attribute . PKI \cite{rfc5280}, WoT.
\end{itemize}

\paragraph{Outsourcing trust}
Some types of security objectives can be efficiently verified by client systems on-the-fly.
%
For example, the \emph{integrity} of a retrieved boot image can be verified at boot time to high confidence against a known hash.

Other objectives are either infeasible to verify locally --- for example, `an adversary with the ability to run unprivileged software cannot achieve a privilege escalation' --- or are informal in nature and cannot in any sense be verified or falsified.
%
When we cannot verify, we need to be able to \emph{trust} boot inputs and processes.
%
This trust is most often inherited from trust in an individual, organization, or brand name --- for example, the authors of a software distribution --- that stands accountable for the good properties of the artefacts.
%
The confidence we can derive from these claims then becomes a function of the nature of the claim and of our trust in the authority's reliability in making such claims.

Hence, to outsource our risk model to a set of claims made by other trusted entities, we would also need an `identity system' comprising:
\begin{itemize}
  \item A scheme for binding identifying attributes, such as common names, to entities, such as natural persons or organisations, that are the subject of trust.
  \item A certification system that binds credentials, such as a public key, with identifying attributes.
  \item A set of authentication methods and accompanying credentials for verifying this binding. 
\end{itemize}
The third item is the subject of authentication methods. See DIDs.
%
The other items form part of what is, in the context of public-private key cryptography, called a \emph{public key infrastructure} \cite{rfc5280}.

Examples of such systems:
\begin{itemize}
  \item
    Probably the most widespread system in use is the Internet public key infrastructure (PKI) based on X.509 certificates \cite{rfc5280}.
    %
    The process for binding entities to their identities is described by a CA's \emph{Certification Practice Statement} (CPS).
  \item 
    JWT \cite{rfc7519} provides an authenticated scheme to bind attributes, called \emph{claims} in this context, to keys (certification). IANA maintains a list of claims.\footnote{\url{https://www.iana.org/assignments/jwt/jwt.xhtml}}
  \item
    Decentralized identifiers (DIDs) provide a way to communicate and validate authentication material.
\end{itemize}
See also \cite{gerck1997overview}.

\paragraph{Claims about artefacts} Given this, we then need a common language and taxonomy for claims that entities can make about the artefacts.
%
The SCITT working group is working on this.\footnote{\url{https://datatracker.ietf.org/wg/scitt/about/}}

Here are some examples of claims about generic software distributions:
\begin{itemize}
  \item Claim that a software distribution has been published under a certain product name by an owning entity.
  \item Existence or non-existence of registered vulnerabilities, for example in the form of CVE records.\footnote{\url{https://www.cve.org/}}
  \item Existence and claims of audits bound to a specific software version. This idea has been floated several times in the context of smart contract deployments.
  \item Claim that a program or library implements a certain interface or fulfils a certain contract.
  \item Claims of concrete security guarantees in a given context and threat model.
\end{itemize}
%
More relevant to the present paper, we may wish to claim that an operating system distribution image is bootable via a stated boot process, or a boot process with certain properties.
%
For instance:
\begin{itemize}
  \item Statement of format of the image (raw partition, raw GPT-formatted partitioned disk with EFI system partition) and entry point to the boot process (EFI system partition, explicit start vector)
  \item List of components used in the boot process.
  \item Boot computation specification in the sense of \S\ref{build}.
  \item Contract implemented between bootloader and payload.
  \item Preservation of privilege level between boot stages.
  \item Boot loader makes use of secure hardware services such as TPM.
\end{itemize}


\subsection{Integrity/tampering boot security problem}

In this section we focus on \emph{integrity,} the most widely
appreciated security goal of a boot flow.

In the boot as computation ``graph'' model described in this article, a
generic security problem runs as follows:

\emph{Context.} A user wants to compute a target \(t\) of a build \(B\)
in several stages \(S_1,\ldots,S_n\). At each stage, some inputs are
consumed and some intermediate targets \(t'\) are computed.

\emph{Adversary.} Between each stage, the (tampering) adversary may
modify the value of the intermediate targets \(t'\).

\emph{Security goal.} The result of the computation is either the true
value of \(t\) or \(\bot\), indicating failure.


\subsection{Some examples}

\paragraph{U-Boot standard boot}

\emph{Context.} An ARM SoC with (trusted) U-Boot firmware is booting a FIT
image,\footnote{\url{https://u-boot.readthedocs.io/en/latest/usage/fit/source_file_format.html}} comprising a kernel, initramfs, device tree blob, and kernel
commandline, which is written by the operator to an SD card.

\emph{Adversary.} May modify the contents of the SD card after the user writes it but before booting.

\emph{Security goal.} Either the specified FIT image is booted, or the boot fails and the system halts.


In terms of build specifications, the problem that is being solved here is the integrity of the boot computation given a cache expansion
\begin{verbatim}
[
  (mmc.data, save, [img.data.0, path]),
  (img.data.1, load, [mmc.data, path])
]
\end{verbatim}
where the adversary may modify the cached value \texttt{mmc.data}, even if it would break the invariant $\mathtt{img.data.0} = \mathtt{img.data.1}$.

For more practical information on this topic, see \cite{timesys2023securing}.

\hypertarget{traditional-package-management}{%
\paragraph{Traditional package
management}\label{traditional-package-management}}

\emph{Context.} A user downloads and install a program from a remote
repository.

\emph{Adversary.} May modify data in transit and at rest on the remote
repository.

\emph{Security goal.} The installed package is the subject of a claim of
authorship by an entity possessing an given public key \(\mathtt{pk}\).

\begin{itemize}
\tightlist
\item
  In widely used package repositories, a package is accompanied by a checksum or hash and a signature of that checksum (in ASCII-armored PEM format).
\item
  The signature may be accompanied by a field indicating the claim associated to the signature in a commonly understood format, for example, the OpenPGP Signature Type byte 0x00 \cite[\S5.2.1]{rfc4880}.\footnote{\url{https://www.rfc-editor.org/rfc/rfc4880.html\#section-5.2.1}}
\item
  The trust of the signing key can be derived from that of the root
  certificate of a TLS certificate chain, for example, those of the DNS
  domain from which the key is fetched. This could be the domain hosting
  the repository itself or a domain known to be owned by the software
  author or other trusted authority.
\end{itemize}

\printbibliography