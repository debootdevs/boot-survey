% DOCUMENT BODY
\maketitle

%\tableofcontents

\begin{abstract}

  We consider bootstrapping computers, also known as bare metal provisioning, in a more general context of deployments and dependent builds. We review the state of the art, exhibit a functional programming inspired data model that expresses builds declaratively and specialize it to a boot context, and discuss the need for and components of a trust-oriented security model for provisioning.

\end{abstract}

\section{Introduction}

Booting computers has long been a somewhat neglected corner of IT infrastructure. 
%
It is often easy to ignore the sequence of unfamiliar and usually poorly documented ephemeral stages a computer quickly steps through between a power cycle and normal operation. 
%
Indeed, one usually expects that a correctly configured system spends only a tiny fraction of its life cycling through these stages.

Despite this, there are a few reasons one may wish to expend attention on the bootloader. 
%
Paramount among these is \emph{security.} 
%
In order to evaluate the security of the software supply chain used in a computer system, one must trace the root of trust all the way to the beginning of the boot sequence.

A second, related issue is \emph{reproducibility}, that is, the art of getting servers into the same state regardless of the starting environment. {[}Why do we have to go all the way back to bare metal for
that?{]} 
%
This is related to the idea of \emph{immutable infrastructure},
otherwise known as the
\href{https://martinfowler.com/bliki/PhoenixServer.html}{phoenix server}
model. In a HA cluster with at least two physical nodes, this power
cycle \(\rightarrow\) bare metal redeployment can be achieved with zero
downtime. See also ``reproducible builds''
(https://hal.science/hal-03196519/, https://reproducible-builds.org).

We think the bootloader is overdue a modern theoretical treatment. 
%
In this article we address the question:
\begin{quote}
  What type of thing is a boot sequence?
\end{quote}
%
An answer to this question empowers us to draw analogies with other types of computation and make more precise and interpretable security claims.
%
A well-defined data model for defining boot sequences can have a number of benefits:

\begin{itemize}
\tightlist
\item
  \emph{Accessibility.} A modern, implementation-agnostic description language means more users understanding and taking control of their own boot sequences.
\item
  \emph{Security.} A serialized boot definition can be used as a part of a \emph{software bill of materials} which is the subject of security claims about a deployment.
\item
  \emph{Extensibility.} The present obscure state of documentation makes it difficult for developers to integrate new technologies such as novel storage backends early in the boot process.
\end{itemize}

The second question we address in this article is:
\begin{quote}
  How can boots be trusted?
\end{quote}

The answers to these questions cannot be divorced from one another.
%
In order to make trustworthy claims about boots, we have to be able to clearly state the subject of the claims.
%
On the other hand, a formal definition of a boot cannot have much practical significance if users cannot be sure that the state reached by their system matches the definition.

In \S\ref{build} we introduce a data model for defining computations and exhibit how typical boot sequence paradigms can be expressed in this model.
%
In \S\ref{security} we discuss elements that would be needed for a formal cybersecurity framework and review some ubiquitous examples with this in mind.


\subsection{Related work}\label{related-work}

For a thorough engineering overview of the structure of boot processes at the firmware level, see \cite{yao2020building}.

There are many cross-industry initiatives to develop standards associated to the boot process:
\begin{itemize}
  \item
   The \emph{Universal Extensible Firmware Interface} (UEFI) is a set of cross-platform standards for an execution environment presented by platform firmware which early stage boot manager or bootloader software can hook into.\footnote{\url{https://uefi.org/specifications}}

  \item
    The \emph{Preboot Execution Environment} (PXE, pronounced `pixie') is a component of the UEFI specification that defines a protocol, based on DHCP and TFTP, for negotiating a network boot.
    %
    It is the standard way to load the next stage after platform firmware over a network, although some systems also offer boot from a webserver.

  \item
    The \emph{Extended Bootloader Base Requirements} (EBBR) are a subset of UEFI designed as a specification compatible with U-Boot, the industry standard firmware and bootloader implementation for embedded systems.\footnote{\url{https://arm-software.github.io/ebbr/}}

  \item
    The \emph{multiboot} specification and its sequel does some work to define the format of OS kernel loaders. 
    %
    Unlike the preceding examples, multiboot does not attempt to specify how systems should operate at the platform firmware level --- its scope is limited to starting an OS.
    %
    The reference implementation of a multiboot-compliant host is the GRUB boot manager, widely used in booting Linux or BSD on x86 computers (although Linux and BSD are not usually distributed as a multiboot-compliant client!)

  \item
    The \emph{boot loader specification} project defines disk formats, file formats, and naming conventions for boot loader menu entries.\footnote{\url{https://uapi-group.org/specifications/specs/boot_loader_specification/}} 
    %
    BLS-compliant menu entry configurations are intended to be OS-agnostic and can be thought of as a data model for a kernel loader boot stage.
    %
    However, boots defined in this format are limited to ones where the boot artifacts are located on local storage, which must be partitioned in one of a few pre-defined layouts. 
    %
    Thus \emph{extensibility} cannot be said to be one of the goals of the project.

\end{itemize}

Applications designed for bare-metal provisioning of fleets of devices in data centres must define their own data model for specifying deployments.
%
Generally speaking, these systems operate over a network (hence use network-based boot protocols, the major one being PXE) and are opinionated about the structure of boot flow.
%
Some examples are OpenStack's \emph{Ironic},\footnote{\url{https://wiki.openstack.org/wiki/Ironic}}, Canonical's \emph{MaaS},\footnote{\url{https://maas.io}}, and Equinix's \emph{Tinkerbell}.\footnote{\url{https://tinkerbell.org/}}

The OpenStack authors have written on the need for a standardized bare metal provisioning API \cite{openstack2023building}.

The early boot and system initialization standards are accompanied by standards defining data models and serialization formats for hardware devices.
%
These models aggregate the addressing systems of various bus types (e.g. PCI) into a single namespace.
%
As well as providing essential input data for boot loaders to discover and initialize peripherals, a path-like serialization format is useful for specifying the location of boot images and configuration in boot definitions.
\begin{itemize}
  \item
    The UEFI specification includes a systematic and quite general language of \emph{devpaths} for defining \emph{locations} for sourcing images.\footnote{\url{https://uefi.org/specs/UEFI/2.10/10\_Protocols\_Device\_Path\_Protocol.html}}

    The \emph{Advanced Configuration and Power Interface} (ACPI), also maintained by the UEFI Forum. Generally something employed at the OS level but which is available to UEFI.
    
  \item
    Devicetree.\footnote{\url{https://www.devicetree.org/}}
\end{itemize}


\section{Boots as computations with cacheing} \label{build}

A boot can be regarded as a set of steps to compute the state of an
initialized system. In some cases, recomputing the value with updated
inputs (i.e.~rebooting) can be accelerated using a caching strategy, so
that a reboot may occur without necessarily going through a full power
cycle (e.g.~switch-root, \texttt{kexec}).

In this section, we repeatedly make use of an analogy with building
(i.e.~compiling) software artifacts.

\hypertarget{data-model}{%
\subsection{Data model}\label{data-model}}

\textbf{Definition.} An \emph{n-ary operation} from types
\((T_1,\ldots,T_n)\) to type \(T_0\) is defined to be a function
\(f:\prod_{i=1}^n T_i \rightarrow T_0\). Note that we index the output
and inputs (in that order) of an \(n\)-ary operation by
\([n]:=\{0,\ldots,n\}\).

A \emph{task} is an operation \(f\) (of any arity \(n\)) together with a
labelling \(\mathtt{name}:[n]\rightarrow \mathtt{String}\) of the inputs
and output by strings and a ``task description,'' which should be an
expression of the underlying function understandable to the computer
environment in which this computation will be executed. The label
\(\mathtt{name}(0)\) of the output of the operation is called the
\emph{target} of the task.

A \emph{build specification} or simply \emph{build} is a set of tasks.
Expressed in a Python-like pseudocode, the data schema looks something
like the following:

\begin{verbatim}
[
    (f, name_0, [name_1, ..., name_n]),
    ...
]
\end{verbatim}

In this picture, the task description would be a Python function and the
labelled source and destination types are denoted by (typed) named
variables. (This is purely illustrative and is certainly not supposed to
suggest a bootloader implemented in Python!)

Or a more precisely specced JSON

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{[}
    \FunctionTok{\{}
        \DataTypeTok{"target"}\FunctionTok{:} \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_0"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_0"}\FunctionTok{\},}
        \DataTypeTok{"inputs"}\FunctionTok{:} \OtherTok{[}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_1"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_1"}\FunctionTok{\}}\OtherTok{,}
            \ErrorTok{...}\OtherTok{,}
            \FunctionTok{\{}\DataTypeTok{"label"}\FunctionTok{:} \StringTok{"name\_n"}\FunctionTok{,} \DataTypeTok{"type"}\FunctionTok{:} \StringTok{"T\_n"}\FunctionTok{\}}\OtherTok{,}
        \OtherTok{]}\FunctionTok{,}
        \DataTypeTok{"task"}\FunctionTok{:} \ErrorTok{@td}
    \FunctionTok{\}}\OtherTok{,}
    \ErrorTok{...}
\OtherTok{]}
\end{Highlighting}
\end{Shaded}

Here \texttt{@td} should be some task description schema whose details
we leave completely open.

A build specification is said to be \emph{solved} if each target is the
output of at most one task. A solved build can be represented as a DAG.

Let \(B\) be a build and \(t\) a target of \(B\), and
\((i_1,\ldots,i_k)\) a set of labels. A \emph{solution} of
\((B,t,(i_1,\ldots,i_k))\) is a subset \(S\) of \(B\) such that:

\begin{itemize}
\tightlist
\item
  \(t\) is a \emph{root} of \(S\), that is, it is the unique target that
  is not also an input.
\item
  \(i_1,\ldots,i_k\) are the leaves of \(S\), i.e.~they are the only
  inputs that are not also targets.
\item
  Every target in \(S\) is the output of at most one rule in \(S\).
\end{itemize}

In other words, a solution of \((B,t,(i_1,\ldots,i_k))\) defines a way
to compute an element of \(T_t\) given elements of
\(T_{i_1},\ldots,T_{i_k}\).

\begin{example}[Makefiles as build specifications]
  We can express the data of a build specification in a Makefile-like syntax as follows:

\begin{verbatim}
name_0: name_1, ... name_n
    echo $(f name_1 ... name_n) > name_0
\end{verbatim}

This can be understood as a genuine Makefile if:

\begin{itemize}
\tightlist
\item
  All the inputs and outputs are ``files;'' that is,
  \(T_i=\mathtt{File}\) for all \(i\). For the purposes of Make, a
  \emph{file} can be understood as a tuple
  \((\mathtt{name},\mathtt{mtime}, \mathtt{data})\).
\item
  \texttt{f} is a shell function.
\item
  Each label appears as the output of at most one step. That is, no step has multiple `providers'.
\end{itemize}

  Recipes in real-life Makefiles (and indeed any build system) are often not pure functions, but rather depend implicitly on some system state whose scope varies on a per-target basis. 
  %
  If one's goal is reproducibility, efforts should be made to list all inputs as explicit dependencies.
\end{example}

\begin{example}[Dependency DAGs] 
  
  It is quite common to encode collections of dependent computations as a directed acyclic graph (DAG).
  %
  If a build has the property that each target appears as the output of at most one rule, then it can be exactly encoded as a DAG with one node for each target and input, where each non-leaf nodes is decorated by the unique rule of which it is a target.

\end{example}

\paragraph{Multiple providers}
%
Unlike DAGs, our data model is flexible enough to describe builds in which a label can be the target of multiple tasks, each considered as good as any other.
%
In the language of dependency management, our dependency formulae are allowed to contain logical disjunction as well as conjunction.

Disjunctive dependencies are extremely common in practical deployment scenarios such as RPM or DEB-based package management, where objects or configuration fragments listed as a dependency of a given package may have several provider packages, only one of which need be installed to satisfy the dependency.

Naturally, examples of multiple providers in the boot process are also plentiful:

\begin{itemize}
  \item
    The feature \texttt{EFI\_BOOT\_SERVICES} is provided by any UEFI-compliant firmware (for example Tianocore EDK2), but also by any firmware complying with the more stripped-down EBBR specification, such as U-Boot.
  \item
    HTTP and other network drivers are available in UEFI, GRUB, or a Linux initramfs.
  \item
    Common Linux filesystems such as Ext4 and BTRFS each have providers (drivers) in the form of GRUB and Linux modules, but are not available in UEFI.
  \item
    An IP address can be derived either from a static configuration option or via DHCP, either of which itself has several providers spread across different boot stages.
\end{itemize}


\subsection{Build stages}

A boot system requires multiple computations that take place at different times and in different contexts. 
%
For example, constructing a UEFI firmware boot into an EFI application can be split into three stages:
\begin{enumerate}
  \item Build and install UEFI firmware to NVRAM.
  \item Build and install EFI application to bootable media.
  \item Power on the device and, where necessary, provide input to configuration menus.
\end{enumerate}
These stages can be expressed as partial evaluations of a single computation that takes, for example, the development environment, the target device, and the user requirements as input.
%
The targets of the associated build specification may be partitioned into connected components labelled by the build stage during which they are evaluated.

\subsection{Examples}

In the following examples, I use the Pythonic notation and explain the typing (for which there are often multiple reasonable approaches) in prose.

\subsubsection{Loading an EFI application}

We start from the assumption that we want to load and boot into an EFI
executable file \texttt{BOOTX64.EFI}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To jump into this program (i.e.~compute the state of an initialized
  system running this program), we need the program binary itself and a
  firmware library function to parse and load PE executable with EFI
  headers.
\item
  To obtain the library function \texttt{efi\_exec}, we need to resolve
  the symbol from a loaded firmware implementation providing this
  feature. Libraries that implement either the UEFI or EBBR
  specifications provide it.
\item
  A UEFI symbol table can be computed by loading it from a UEFI
  implementation, such as Tianocore's OVMF firmware for virtual
  machines. It is presumed that this firmware is loaded from a canonical
  location (e.g.~NVRAM) known to the first stage bootloader, so we do
  not add further tasks to source this.
\item
  The EFI program binary can be computed by fetching it from a storage
  location. We can treat the system I/O bus as an oracle from which we
  fetch things by passing an address. For example, within the UEFI
  abstraction layer, this address could be typed as a
  \href{https://uefi.org/specs/UEFI/2.10/10_Protocols_Device_Path_Protocol.html}{UEFI
  Device Path}. (Again, the fetcher will need to resolve symbols for the
  drivers to resolve these paths --- for example, a VFAT filesystem and
  mass storage device driver --- but to avoid repetition in this purely
  illustrative example, we do not make these tasks explicit in the
  listing below.)
\item
  The boot device path is read from the boot menu table in the EFIVARS
  section of NVRAM. The line number is either the configured default or
  is entered in an interactive user session.
\item
  \texttt{efi-boot-number} is a natural number, denoting the menu entry
  selected by a user via an interactive console session.
\end{enumerate}

We could go still further and define providers of \texttt{Console} (e.g.~UART serial or graphical output), but the point has been made.

\begin{verbatim}
[
    (apply, Exec(efi.Application), [efi.start, efi.Application]),
    (apply, efi.Application, [efi.load, boot_devicepath]),
    (resolve, efi.start, [Interface(efi.BootServices), "StartImage"]),
    (resolve, efi.load, [Interface(efi.BootServices), "LoadImage"]),
]
\end{verbatim}
Technical details like memory addresses and passing through parent context are omitted.

%The leaves of this build specification are the UEFI DevicePath \texttt{boot-devicepath} and the interface \texttt{Provides(EFI_BOOT_SERVICES)}. 
%
If the firmware implementation is considered as a separate input to the EFI variables, the computation can be divided into \emph{build-time} versus \emph{configure-time}, and we could add the following build-time tasks:
\begin{verbatim}
[
    (efi.BootServices, Interface(efi.BootServices), [Interface(UEFI)]),
    (efi.BootServices, Interface(efi.BootServices), [Interface(EBBR)]),
    (load_uefi, Interface(UEFI), ["OVMF.fd"]),
]
\end{verbatim}

Adding user input via a firmware boot option selection screen:
\begin{verbatim}
[
    (efi.getvar, boot_devicepath, [Interface(efi.RuntimeServices), efivars.1, "BootCurrent"]),
    (efi.setvar, efivars.1, [Interface(efi.RuntimeServices), efivars.0, "BootCurrent", boot_option]),
    (efi.get_input, boot_option, [Provides(Console), INPUT]),
]
\end{verbatim}
The \texttt{get\_input} function is a summary of a potentially complex interaction.
%
Some details are specified by the \emph{Human Interface Infrastructure} (HII) component of UEFI.\footnote{\url{https://uefi.org/specs/UEFI/2.10/33_Human_Interface_Infrastructure.html}}


Note that in this application, some leaf variables (\texttt{efi-bootmenu} and console configuration) can be easily
reconfigured without reinstalling the firmware image itself. 
%
This is called making use of a cached build output.
%
An automated build system could use knowledge of the services provided by firmware and available media to automatically select locations to persistently cache intermediate computations such as firmware, kernel loaders, boot images, and configuration.

\subsubsection{Loading Linux with a kernel command line}

Here's how a typical invocation of the kernel looks.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  To initialize the state, we need a Linux kernel and a kernel commandline. 
  %
  The kernel command line must at least have a \texttt{root=} argument. 
  %
  If an initramfs is used, we also need the underlying data for that as well as the corresponding command line argument. 
\item
  The kernel and initramfs have type \(\mathbb{B}^\star\),
  %
  The other leaves \texttt{root} and \texttt{extra\_params} have type \(\mathtt{String}\).
\item
  If the bootloader also has to fetch \texttt{vmlinuz} from a peripheral
  (i.e.~it is not already assumed to reside in a hardcoded location),
  then we can add a fetch stage for that too. The type of the input
  \texttt{kernel-path} should depend on the environment and available
  drivers for fetching. For example, if the implicit context is GRUB,
  \texttt{kernel-path} should be typed as a
  \href{https://www.gnu.org/software/grub/manual/grub/grub.html\#Naming-convention}{GRUB
  path}.
\end{enumerate}

\begin{verbatim}
# Initramfs boot with requirements deduced from kernel commandline
[
    (run, Init(Linux), [loader, kernel, initramfs, root, args]),
    (build, initramfs, [kernel_modules, root]),
]
\end{verbatim}

The leaves of the build are \texttt{loader}, \texttt{kernel}, \texttt{root}, and \texttt{args}. 
%
The \texttt{initramfs} target is computed a build time and cached on a boot medium.
%
The expanded computation is
\begin{verbatim}
  # Initramfs boot with requirements deduced from kernel commandline
  [
      (run, Init(Linux), [loader, kernel, initramfs, root, args]),
      (load, kernel, [bootdev.state, kernel_path]),
      (load, initramfs, [bootdev.state, initramfs_path]),
      (save, bootdev.state, [initramfs, initramfs_path]),
      (build, initramfs, [kernel_modules, root]),
  ]
\end{verbatim}
The runtime leaves \texttt{kernel\_path}, \texttt{initramfs\_path}, and \texttt{root}+\texttt{args} are exactly the data to be found in a typical Linux boot option configuration.\footnote{\url{https://uapi-group.org/specifications/specs/boot\_loader\_specification/\#type-1-boot-loader-specification-entries}}

\subsubsection{Multi stage boot}

In all but the simplest scenarios, boots need to go through several stages because the resources ne ed to fetch the operating system need codecs or drivers not available at the first stage.

Typically, the full computation falls into several stages:
\begin{enumerate}
  \item \emph{Build.} Build and install platform firmware and bootloader.
  \item \emph{Configure.} Build kernel, initramfs containing relevant rootfs drivers, and userspace, and configure kernel loading, including kernel command line.
  \item \emph{Run.} Capture runtime user interaction and compute system initialization state.
\end{enumerate}

\begin{enumerate}
  \item Booting a program that resides on a filesystem other than FAT; tor example, \texttt{ext4} or \texttt{btrfs}. 
  %
  The target \texttt{btrfs} is provided by either GRUB or Linux.
  %
  Similarly, the kernel is an ELF executable and not an EFI PE; this is also provided by GRUB or Linux. 
  
  \item Boot a kernel that lives on an attached storage device whose filesystem may be any of a list of supported filesystems. 
  %
  Which one it is is autodetected on startup (a dynamic dependency). 
  
  \item Boot an image fetched from novel store (Swarm, IPFS, Arweave\ldots) that has been developed for a full OS, e.g.~Linux, BSD, MacOS, Windows. 
  %
  Your dependency is that OS and an init process that launches the client for the novel protocol.
  
  \item 
    You want to capture user input interactively --- a dynamic dependency.
    %
    \begin{itemize}
      \item Selection from several hardcoded boot options --- provided by UEFI.
      \item Selection from several boot options with an interactive editor to modify them. Dependency is \texttt{grub}.
      \item Shell with various capabilities. Available UEFI, GRUB, Linux+initramfs\ldots{} 
    \end{itemize}
    


\end{enumerate}

\begin{example}[HTTP boot]

  Fetch an image from the WAN over HTTP with static network configuration. 
  %
  Requires network interface drivers, a TCP/IP stack, and HTTP. 
  
  \begin{enumerate}
  \item Same as above but with HTTPS. 
  %
  In addition to the above you need TLS and root certificates (as trust anchor or with trust derivable from a trust anchor). 
  %
  Typically this would be used with DNS.

  \item HTTP boot but also verifying a PGP signature. 
  %
  Requires a PGP implementation and the signing pubkey (as trust anchor or with trust derivable from a trust anchor). 
  
  \item HTTP boot plus verifying a modern signature scheme with less widespread support, such as BLS with signature aggregation. 
  %
  Dependency is \texttt{bls-verify\ -\textgreater{}\ linux} (probably.) 
  
  \item HTTP boot with network layer autoconfiguration --- a dynamic dependency. 
  %
  Provided by DHCP, DHCPv6, or RA. 
  
  \item HTTP boot, but the image URL is a DNS name rather than an IP address. 
  %
  You need \texttt{dns-client}. If using DHCP, requiers a DHCP client plugin that registers the DNS server address field.
  \end{enumerate}

\end{example}

\section{Security} \label{security}

How can we trust boots?
%
To approach the question, we must first make it more precise:
\begin{quote}
  How can we \emph{estimate} and \emph{optimize} the probability that, given a set of assumptions about the environment and the capabilities of an adversary, booting a system puts it into a state with desirable properties?
\end{quote}
The `desirable properties' of the booted system state are our \emph{security objectives}; the capabilities of an adversary are the \emph{threat model}.

A practical boot security framework would provide:
\begin{itemize}
  \item A boot risk management language. A nomenclature for common boot security objectives, assumptions, and threats.
  \item Methods for evaluating risk.
  \item Methods for constrained optimization of risk.
\end{itemize}
For our nomenclature we should draw on the language of firmware and boot loader development practitioners \cite{yao2020building} as well as the models associated to the various information security frameworks in use across the industry \cite{taherdoost2022understanding}. 
%
Here is a short list to get us started:
\begin{itemize}
  \item Security goals: Information security's famous `CIA triad' of \emph{confidentiality, availability, integrity}, and possible extensions, e.g.~\emph{authentication, non-repudiation}.
  \item The STRIDE threat model. Attack trees.
  \item Secure boot
  \item TPM. Measurements.
  \item Identity, a.k.a.~binding key material to an identifier or attribute . PKI \cite{rfc5280}, WoT.
\end{itemize}

\paragraph{Outsourcing trust}
Some types of security objectives can be efficiently verified by client systems on-the-fly.
%
For example, the \emph{integrity} of a retrieved boot image can be verified at boot time to high confidence against a known hash.

Other objectives are either infeasible to verify locally --- for example, `an adversary with the ability to run unprivileged software cannot achieve a privilege escalation' --- or are informal in nature and cannot in any sense be verified or falsified.
%
When we cannot verify, we need to be able to \emph{trust} boot inputs and processes.
%
This trust is most often inherited from trust in an individual, organization, or brand name --- for example, the authors of a software distribution --- that stands accountable for the good properties of the artefacts.
%
The confidence we can derive from these claims then becomes a function of the nature of the claim and of our trust in the authority's reliability in making such claims.

Hence, to outsource our risk model to a set of claims made by other trusted entities, we would also need an `identity system' comprising:
\begin{itemize}
  \item A scheme for binding identifying attributes, such as common names, to entities, such as natural persons or organisations, that are the subject of trust.
  \item A certification system that binds credentials, such as a public key, with identifying attributes.
  \item A set of authentication methods and accompanying credentials for verifying this binding. 
\end{itemize}
The third item is the subject of authentication methods. See DIDs.
%
The other items form part of what is, in the context of public-private key cryptography, called a \emph{public key infrastructure} \cite{rfc5280}.

Examples of such systems:
\begin{itemize}
  \item
    Probably the most widespread system in use is the Internet public key infrastructure (PKI) based on X.509 certificates \cite{rfc5280}.
    %
    The process for binding entities to their identities is described by a CA's \emph{Certification Practice Statement} (CPS).
  \item 
    JWT \cite{rfc7519} provides an authenticated scheme to bind attributes, called \emph{claims} in this context, to keys (certification). IANA maintains a list of claims.\footnote{\url{https://www.iana.org/assignments/jwt/jwt.xhtml}}
  \item
    Decentralized identifiers (DIDs) provide a way to communicate and validate authentication material.
\end{itemize}
See also \cite{gerck1997overview}.

\paragraph{Claims about artefacts} Given this, we then need a common language and taxonomy for claims that entities can make about the artefacts.
%
The SCITT working group is working on this.\footnote{\url{https://datatracker.ietf.org/wg/scitt/about/}}

Here are some examples of claims about generic software distributions:
\begin{itemize}
  \item Claim that a software distribution has been published under a certain product name by an owning entity.
  \item Existence or non-existence of registered vulnerabilities, for example in the form of CVE records.\footnote{\url{https://www.cve.org/}}
  \item Existence and claims of audits bound to a specific software version. This idea has been floated several times in the context of smart contract deployments.
  \item Claim that a program or library implements a certain interface or fulfils a certain contract.
  \item Claims of concrete security guarantees in a given context and threat model.
\end{itemize}
%
More relevant to the present paper, we may wish to claim that an operating system distribution image is bootable via a stated boot process, or a boot process with certain properties.
%
For instance:
\begin{itemize}
  \item Statement of format of the image (raw partition, raw GPT-formatted partitioned disk with EFI system partition) and entry point to the boot process (EFI system partition, explicit start vector)
  \item List of components used in the boot process.
  \item Boot computation specification in the sense of \S\ref{build}.
  \item Contract implemented between bootloader and payload.
  \item Preservation of privilege level between boot stages.
  \item Boot loader makes use of secure hardware services such as TPM.
\end{itemize}


\subsection{Integrity/tampering boot security problem}

In this section we focus on \emph{integrity,} the most widely
appreciated security goal of a boot flow.

In the boot as computation ``graph'' model described in this article, a
generic security problem runs as follows:

\emph{Context.} A user wants to compute a target \(t\) of a build \(B\)
in several stages \(S_1,\ldots,S_n\). At each stage, some inputs are
consumed and some intermediate targets \(t'\) are computed.

\emph{Adversary.} Between each stage, the (tampering) adversary may
modify the value of the intermediate targets \(t'\).

\emph{Security goal.} The result of the computation is either the true
value of \(t\) or \(\bot\), indicating failure.


\subsection{Some examples}

\paragraph{U-Boot standard boot}

\emph{Context.} An ARM SoC with (trusted) U-Boot firmware is booting a FIT
image,\footnote{\url{https://u-boot.readthedocs.io/en/latest/usage/fit/source_file_format.html}} comprising a kernel, initramfs, device tree blob, and kernel
commandline, which is written by the operator to an SD card.

\emph{Adversary.} May modify the contents of the SD card after the user writes it but before booting.

\emph{Security goal.} Either the specified FIT image is booted, or the boot fails and the system halts.


In terms of build specifications, the problem that is being solved here is the integrity of the boot computation given a cache expansion
\begin{verbatim}
[
  (mmc.data, save, [img.data.0, path]),
  (img.data.1, load, [mmc.data, path])
]
\end{verbatim}
where the adversary may modify the cached value \texttt{mmc.data}, even if it would break the invariant $\mathtt{img.data.0} = \mathtt{img.data.1}$.

For more practical information on this topic, see \cite{timesys2023securing}.

\hypertarget{traditional-package-management}{%
\paragraph{Traditional package
management}\label{traditional-package-management}}

\emph{Context.} A user downloads and install a program from a remote
repository.

\emph{Adversary.} May modify data in transit and at rest on the remote
repository.

\emph{Security goal.} The installed package is the subject of a claim of
authorship by an entity possessing an given public key \(\mathtt{pk}\).

\begin{itemize}
\tightlist
\item
  In widely used package repositories, a package is accompanied by a checksum or hash and a signature of that checksum (in ASCII-armored PEM format).
\item
  The signature may be accompanied by a field indicating the claim associated to the signature in a commonly understood format, for example, the OpenPGP Signature Type byte 0x00 \cite[\S5.2.1]{rfc4880}.\footnote{\url{https://www.rfc-editor.org/rfc/rfc4880.html\#section-5.2.1}}
\item
  The trust of the signing key can be derived from that of the root
  certificate of a TLS certificate chain, for example, those of the DNS
  domain from which the key is fetched. This could be the domain hosting
  the repository itself or a domain known to be owned by the software
  author or other trusted authority.
\end{itemize}

\printbibliography